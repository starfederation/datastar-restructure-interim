{
  "version": 3,
  "sources": ["../code/ts/library/src/plugins/official/attributes/core/computed.ts", "../code/ts/library/src/utils/signals.ts", "../code/ts/library/src/plugins/official/attributes/core/store.ts", "../code/ts/library/src/utils/regex.ts", "../code/ts/library/src/plugins/official/preprocessors/core/actions.ts", "../code/ts/library/src/plugins/official/preprocessors/core/signals.ts", "../code/ts/library/src/utils/dom.ts", "../code/ts/library/src/vendored/preact-core.ts", "../code/ts/library/src/vendored/deepsignal.ts", "../code/ts/library/src/vendored/ts-merge-patch.ts", "../code/ts/library/src/engine/const.ts", "../code/ts/library/src/engine/version.ts", "../code/ts/library/src/engine/engine.ts", "../code/ts/library/src/engine/index.ts", "../code/ts/library/src/plugins/official/actions/backend/isFetching.ts", "../code/ts/library/src/plugins/official/actions/backend/remote.ts", "../code/ts/library/src/vendored/fetch-event-source/parse.ts", "../code/ts/library/src/vendored/fetch-event-source/fetch.ts", "../code/ts/library/src/plugins/official/attributes/backend/fetchIndicator.ts", "../code/ts/library/src/utils/text.ts", "../code/ts/library/src/plugins/official/watchers/backend/sseShared.ts", "../code/ts/library/src/plugins/official/actions/backend/sseShared.ts", "../code/ts/library/src/plugins/official/actions/backend/sseDelete.ts", "../code/ts/library/src/plugins/official/actions/backend/sseGet.ts", "../code/ts/library/src/plugins/official/actions/backend/ssePatch.ts", "../code/ts/library/src/plugins/official/actions/backend/ssePost.ts", "../code/ts/library/src/plugins/official/actions/backend/ssePut.ts", "../code/ts/library/src/plugins/official/actions/dom/clipboard.ts", "../code/ts/library/src/plugins/official/actions/dom/ref.ts", "../code/ts/library/src/plugins/official/actions/logic/setAll.ts", "../code/ts/library/src/plugins/official/actions/logic/toggleAll.ts", "../code/ts/library/src/plugins/official/actions/math/clampFit.ts", "../code/ts/library/src/plugins/official/actions/math/clampFitInt.ts", "../code/ts/library/src/plugins/official/actions/math/fit.ts", "../code/ts/library/src/plugins/official/actions/math/fitInt.ts", "../code/ts/library/src/plugins/official/attributes/backend/header.ts", "../code/ts/library/src/plugins/official/attributes/backend/replaceUrl.ts", "../code/ts/library/src/plugins/official/attributes/dom/bind.ts", "../code/ts/library/src/plugins/official/attributes/dom/class.ts", "../code/ts/library/src/plugins/official/attributes/dom/model.ts", "../code/ts/library/src/utils/arguments.ts", "../code/ts/library/src/utils/timing.ts", "../code/ts/library/src/plugins/official/attributes/dom/on.ts", "../code/ts/library/src/plugins/official/attributes/dom/ref.ts", "../code/ts/library/src/plugins/official/attributes/dom/text.ts", "../code/ts/library/src/plugins/official/attributes/storage/persist.ts", "../code/ts/library/src/plugins/official/attributes/visibility/intersects.ts", "../code/ts/library/src/plugins/official/attributes/visibility/scrollIntoView.ts", "../code/ts/library/src/plugins/official/attributes/visibility/show.ts", "../code/ts/library/src/plugins/official/attributes/visibility/teleport.ts", "../code/ts/library/src/utils/view-transitions.ts", "../code/ts/library/src/plugins/official/attributes/visibility/viewTransition.ts", "../code/ts/library/src/plugins/official/watchers/backend/sseDispatchCustomEvent.ts", "../code/ts/library/src/plugins/official/watchers/backend/sseExecuteJS.ts", "../code/ts/library/src/vendored/idiomorph.ts", "../code/ts/library/src/plugins/official/watchers/backend/sseMergeFragment.ts", "../code/ts/library/src/plugins/official/watchers/backend/sseMergeSignals.ts", "../code/ts/library/src/plugins/official/watchers/backend/sseRemoveFragments.ts", "../code/ts/library/src/plugins/official/watchers/backend/sseRemoveSignals.ts", "../code/ts/library/src/bundles/datastar.ts"],
  "sourcesContent": ["// Authors: Delaney Gillilan\n// Icon: fluent:draw-text-24-filled\n// Slug: Create a computed signal\n// Description: This attribute creates a computed signal that updates when its dependencies change.\n\nimport { AttributePlugin } from \"../../../../engine\";\n\nexport const Computed: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"computed\",\n    mustNotEmptyKey: true,\n    onLoad: (ctx) => {\n        const store = ctx.store();\n        store[ctx.key] = ctx.reactivity.computed(() => {\n            return ctx.expressionFn(ctx);\n        });\n\n        return () => {\n            const store = ctx.store();\n            delete store[ctx.key];\n        };\n    },\n};\n", "export function remoteSignals(obj: Object): Object {\n    const res: Record<string, any> = {};\n\n    for (const [k, v] of Object.entries(obj)) {\n        if (k.startsWith(\"_\")) {\n            continue;\n        } else if (typeof v === \"object\" && !Array.isArray(v)) {\n            res[k] = remoteSignals(v); // recurse\n        } else {\n            res[k] = v;\n        }\n    }\n\n    return res;\n}\n\nexport function storeFromPossibleContents(\n    currentStore: any,\n    contents: any,\n    hasIfMissing: boolean,\n) {\n    const actual: any = {};\n\n    if (!hasIfMissing) {\n        Object.assign(actual, contents);\n    } else {\n        for (const key in contents) {\n            const currentValue = currentStore[key]?.value;\n            if (currentValue === undefined || currentValue === null) {\n                actual[key] = contents[key];\n            }\n        }\n    }\n\n    return actual;\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:home-storage\n// Slug: Store signals into a singleton per page\n// Description: This action stores signals into a singleton per page. This is useful for storing signals that are used across multiple components.\n\nimport {\n    AttributeContext,\n    AttributePlugin,\n    RegexpGroups,\n} from \"../../../../engine\";\nimport { storeFromPossibleContents } from \"../../../../utils/signals\";\n\n// Setup the global store\nexport const Store: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"store\",\n    removeNewLines: true,\n    preprocessors: {\n        pre: [\n            {\n                pluginType: \"preprocessor\",\n                name: \"store\",\n                regexp: /(?<whole>.+)/g,\n                replacer: (groups: RegexpGroups) => {\n                    const { whole } = groups;\n                    return `Object.assign({...ctx.store()}, ${whole})`;\n                },\n            },\n        ],\n    },\n    allowedModifiers: new Set([\"ifmissing\"]),\n    onLoad: (ctx: AttributeContext) => {\n        const possibleMergeStore = ctx.expressionFn(ctx);\n        const actualMergeStore = storeFromPossibleContents(\n            ctx.store(),\n            possibleMergeStore,\n            ctx.modifiers.has(\"ifmissing\"),\n        );\n        ctx.mergeStore(actualMergeStore);\n\n        delete ctx.el.dataset[ctx.rawKey];\n    },\n};\n", "export const validJSIdentifier = `[a-zA-Z_$]+`;\nexport const validNestedJSIdentifier = validJSIdentifier + `[0-9a-zA-Z_$.]*`;\n\nexport function wholePrefixSuffix(\n    rune: string,\n    prefix: string,\n    suffix: string,\n    nestable = true,\n) {\n    const identifier = nestable ? validNestedJSIdentifier : validJSIdentifier;\n    return new RegExp(\n        `(?<whole>${rune}(?<${prefix}>${identifier})${suffix})`,\n        `g`,\n    );\n}\n", "import { PreprocessorPlugin, RegexpGroups } from \"../../../../engine\";\nimport { wholePrefixSuffix } from \"../../../../utils/regex\";\n\n// Replacing $action(args) with ctx.actions.action(ctx, args)\nexport const ActionsProcessor: PreprocessorPlugin = {\n    name: \"action\",\n    pluginType: \"preprocessor\",\n    regexp: wholePrefixSuffix(\n        \"\\\\$\",\n        \"action\",\n        \"(?<call>\\\\((?<args>.*)\\\\))\",\n        false,\n    ),\n    replacer: ({ action, args }: RegexpGroups) => {\n        const withCtx = [`ctx`];\n        if (args) {\n            withCtx.push(...args.split(\",\").map((x) => x.trim()));\n        }\n        const argsJoined = withCtx.join(\",\");\n        return `ctx.actions.${action}.method(${argsJoined})`;\n    },\n};\n", "import { PreprocessorPlugin, RegexpGroups } from \"../../../../engine\";\nimport { wholePrefixSuffix } from \"../../../../utils/regex\";\n\n// Replacing $signal with ctx.store.signal.value`\nexport const SignalsProcessor: PreprocessorPlugin = {\n    name: \"signal\",\n    pluginType: \"preprocessor\",\n    regexp: wholePrefixSuffix(\"\\\\$\", \"signal\", \"(?<method>\\\\([^\\\\)]*\\\\))?\"),\n    replacer: (groups: RegexpGroups) => {\n        const { signal, method } = groups;\n        const prefix = `ctx.store()`;\n        if (!method?.length) {\n            return `${prefix}.${signal}.value`;\n        }\n        const parts = signal.split(\".\");\n        const methodName = parts.pop();\n        const nestedSignal = parts.join(\".\");\n        return `${prefix}.${nestedSignal}.value.${methodName}${method}`;\n    },\n};\n", "import { HTMLorSVGElement } from \"./types\";\n\nexport function elemToSelector(\n    elm: Element | Window | Document | string | null,\n) {\n    if (!elm) return \"null\";\n    if (typeof elm === \"string\") return elm;\n    if (elm instanceof Window) return \"Window\";\n    if (elm instanceof Document) return \"Document\";\n\n    if (elm.tagName === \"BODY\") return \"BODY\";\n    const names = new Array<string>();\n    while (elm.parentElement && elm.tagName !== \"BODY\") {\n        if (elm.id) {\n            const idAttr = elm.getAttribute(\"id\");\n            if (!idAttr) {\n                throw new Error(\"Element has an ID but no ID attribute\");\n            }\n            names.unshift(\"#\" + idAttr); // getAttribute, because `elm.id` could also return a child element with name \"id\"\n            break; // Because ID should be unique, no more is needed. Remove the break, if you always want a full path.\n        } else {\n            let c = 1,\n                e = elm;\n            for (; e.previousElementSibling; e = e.previousElementSibling, c++);\n            names.unshift(elm.tagName + \":nth-child(\" + c + \")\");\n        }\n        elm = elm.parentElement;\n    }\n    return names.join(\">\");\n}\n\nexport function nodeHTMLorSVGElement(node: Node): HTMLorSVGElement | null {\n    if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\n        return null;\n    }\n    return node;\n}\n\nexport function scrollIntoView(\n    el: HTMLElement | SVGElement,\n    opts: ScrollIntoViewOptions,\n    shouldFocus = true,\n) {\n    if (!(el instanceof HTMLElement || el instanceof SVGElement)) {\n        throw new Error(\"Element not found\");\n    }\n    if (!el.tabIndex) el.setAttribute(\"tabindex\", \"0\");\n\n    el.scrollIntoView(opts);\n    if (shouldFocus) el.focus();\n}\n", "// An named symbol/brand for detecting Signal instances even when they weren't\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for(\"preact-signals\");\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n  // A source whose value the target depends on.\n  _source: Signal;\n  _prevSource?: Node;\n  _nextSource?: Node;\n\n  // A target that depends on the source and should be notified when the source changes.\n  _target: Computed | Effect;\n  _prevTarget?: Node;\n  _nextTarget?: Node;\n\n  // The version number of the source that target has last seen. We use version numbers\n  // instead of storing the source value, because source values can take arbitrary amount\n  // of memory, and computeds could hang on to them forever because they're lazily evaluated.\n  // Use the special value -1 to mark potentially unused but recyclable nodes.\n  _version: number;\n\n  // Used to remember & roll back the source's previous `._node` value when entering &\n  // exiting a new evaluation context.\n  _rollbackNode?: Node;\n};\n\nfunction startBatch() {\n  batchDepth++;\n}\n\nfunction endBatch() {\n  if (batchDepth > 1) {\n    batchDepth--;\n    return;\n  }\n\n  let error: unknown;\n  let hasError = false;\n\n  while (batchedEffect !== undefined) {\n    let effect: Effect | undefined = batchedEffect;\n    batchedEffect = undefined;\n\n    batchIteration++;\n\n    while (effect !== undefined) {\n      const next: Effect | undefined = effect._nextBatchedEffect;\n      effect._nextBatchedEffect = undefined;\n      effect._flags &= ~NOTIFIED;\n\n      if (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n        try {\n          effect._callback();\n        } catch (err) {\n          if (!hasError) {\n            error = err;\n            hasError = true;\n          }\n        }\n      }\n      effect = next;\n    }\n  }\n  batchIteration = 0;\n  batchDepth--;\n\n  if (hasError) {\n    throw error;\n  }\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n  if (batchDepth > 0) {\n    return fn();\n  }\n  /*@__INLINE__**/ startBatch();\n  try {\n    return fn();\n  } finally {\n    endBatch();\n  }\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n  const prevContext = evalContext;\n  evalContext = undefined;\n  try {\n    return fn();\n  } finally {\n    evalContext = prevContext;\n  }\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n  if (evalContext === undefined) {\n    return undefined;\n  }\n\n  let node = signal._node;\n  if (node === undefined || node._target !== evalContext) {\n    /**\n     * `signal` is a new dependency. Create a new dependency node, and set it\n     * as the tail of the current context's dependency list. e.g:\n     *\n     * { A <-> B       }\n     *         \u2191     \u2191\n     *        tail  node (new)\n     *               \u2193\n     * { A <-> B <-> C }\n     *               \u2191\n     *              tail (evalContext._sources)\n     */\n    node = {\n      _version: 0,\n      _source: signal,\n      _prevSource: evalContext._sources,\n      _nextSource: undefined,\n      _target: evalContext,\n      _prevTarget: undefined,\n      _nextTarget: undefined,\n      _rollbackNode: node,\n    };\n\n    if (evalContext._sources !== undefined) {\n      evalContext._sources._nextSource = node;\n    }\n    evalContext._sources = node;\n    signal._node = node;\n\n    // Subscribe to change notifications from this dependency if we're in an effect\n    // OR evaluating a computed signal that in turn has subscribers.\n    if (evalContext._flags & TRACKING) {\n      signal._subscribe(node);\n    }\n    return node;\n  } else if (node._version === -1) {\n    // `signal` is an existing dependency from a previous evaluation. Reuse it.\n    node._version = 0;\n\n    /**\n     * If `node` is not already the current tail of the dependency list (i.e.\n     * there is a next node in the list), then make the `node` the new tail. e.g:\n     *\n     * { A <-> B <-> C <-> D }\n     *         \u2191           \u2191\n     *        node   \u250C\u2500\u2500\u2500 tail (evalContext._sources)\n     *         \u2514\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2510\n     *               \u2193     \u2193\n     * { A <-> C <-> D <-> B }\n     *                     \u2191\n     *                    tail (evalContext._sources)\n     */\n    if (node._nextSource !== undefined) {\n      node._nextSource._prevSource = node._prevSource;\n\n      if (node._prevSource !== undefined) {\n        node._prevSource._nextSource = node._nextSource;\n      }\n\n      node._prevSource = evalContext._sources;\n      node._nextSource = undefined;\n\n      evalContext._sources!._nextSource = node;\n      evalContext._sources = node;\n    }\n\n    // We can assume that the currently evaluated effect / computed signal is already\n    // subscribed to change notifications from `signal` if needed.\n    return node;\n  }\n  return undefined;\n}\n\n/**\n * The base class for plain and computed signals.\n */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style prototypes.\n// This enables better control of the transpiled output size.\ndeclare class Signal<T = any> {\n  /** @internal */\n  _value: unknown;\n\n  /**\n   * @internal\n   * Version numbers should always be >= 0, because the special value -1 is used\n   * by Nodes to signify potentially unused but recyclable nodes.\n   */\n  _version: number;\n\n  /** @internal */\n  _node?: Node;\n\n  /** @internal */\n  _targets?: Node;\n\n  constructor(value?: T);\n\n  /** @internal */\n  _refresh(): boolean;\n\n  /** @internal */\n  _subscribe(node: Node): void;\n\n  /** @internal */\n  _unsubscribe(node: Node): void;\n\n  subscribe(fn: (value: T) => void): () => void;\n\n  valueOf(): T;\n\n  toString(): string;\n\n  toJSON(): T;\n\n  peek(): T;\n\n  brand: typeof BRAND_SYMBOL;\n\n  get value(): T;\n  set value(value: T);\n}\n\n/** @internal */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style prototypes.\n// This enables better control of the transpiled output size.\nfunction Signal(this: Signal, value?: unknown) {\n  this._value = value;\n  this._version = 0;\n  this._node = undefined;\n  this._targets = undefined;\n}\n\nSignal.prototype.brand = BRAND_SYMBOL;\n\nSignal.prototype._refresh = function () {\n  return true;\n};\n\nSignal.prototype._subscribe = function (node) {\n  if (this._targets !== node && node._prevTarget === undefined) {\n    node._nextTarget = this._targets;\n    if (this._targets !== undefined) {\n      this._targets._prevTarget = node;\n    }\n    this._targets = node;\n  }\n};\n\nSignal.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the signal has any subscribers to begin with.\n  if (this._targets !== undefined) {\n    const prev = node._prevTarget;\n    const next = node._nextTarget;\n    if (prev !== undefined) {\n      prev._nextTarget = next;\n      node._prevTarget = undefined;\n    }\n    if (next !== undefined) {\n      next._prevTarget = prev;\n      node._nextTarget = undefined;\n    }\n    if (node === this._targets) {\n      this._targets = next;\n    }\n  }\n};\n\nSignal.prototype.subscribe = function (fn) {\n  return effect(() => {\n    const value = this.value;\n\n    const prevContext = evalContext;\n    evalContext = undefined;\n    try {\n      fn(value);\n    } finally {\n      evalContext = prevContext;\n    }\n  });\n};\n\nSignal.prototype.valueOf = function () {\n  return this.value;\n};\n\nSignal.prototype.toString = function () {\n  return this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n  return this.value;\n};\n\nSignal.prototype.peek = function () {\n  const prevContext = evalContext;\n  evalContext = undefined;\n  try {\n    return this.value;\n  } finally {\n    evalContext = prevContext;\n  }\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n  get(this: Signal) {\n    const node = addDependency(this);\n    if (node !== undefined) {\n      node._version = this._version;\n    }\n    return this._value;\n  },\n  set(this: Signal, value) {\n    if (value !== this._value) {\n      if (batchIteration > 100) {\n        throw new Error(\"Cycle detected\");\n      }\n\n      this._value = value;\n      this._version++;\n      globalVersion++;\n\n      /**@__INLINE__*/ startBatch();\n      try {\n        for (\n          let node = this._targets;\n          node !== undefined;\n          node = node._nextTarget\n        ) {\n          node._target._notify();\n        }\n      } finally {\n        endBatch();\n      }\n    }\n  },\n});\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T): Signal<T>;\nexport function signal<T = undefined>(): Signal<T | undefined>;\nexport function signal<T>(value?: T): Signal<T> {\n  return new Signal(value);\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n  // Check the dependencies for changed values. The dependency list is already\n  // in order of use. Therefore if multiple dependencies have changed values, only\n  // the first used dependency is re-evaluated at this point.\n  for (\n    let node = target._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    // If there's a new version of the dependency before or after refreshing,\n    // or the dependency has something blocking it from refreshing at all (e.g. a\n    // dependency cycle), then we need to recompute.\n    if (\n      node._source._version !== node._version ||\n      !node._source._refresh() ||\n      node._source._version !== node._version\n    ) {\n      return true;\n    }\n  }\n  // If none of the dependencies have changed values since last recompute then\n  // there's no need to recompute.\n  return false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n  /**\n   * 1. Mark all current sources as re-usable nodes (version: -1)\n   * 2. Set a rollback node if the current node is being used in a different context\n   * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n   *\n   *    { undefined <- A <-> B <-> C -> undefined }\n   *                   \u2191           \u2191\n   *                   \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   * target._sources = A; (node is head)  \u2502\n   *                   \u2193                  \u2502\n   * target._sources = C; (node is tail) \u2500\u2518\n   */\n  for (\n    let node = target._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    const rollbackNode = node._source._node;\n    if (rollbackNode !== undefined) {\n      node._rollbackNode = rollbackNode;\n    }\n    node._source._node = node;\n    node._version = -1;\n\n    if (node._nextSource === undefined) {\n      target._sources = node;\n      break;\n    }\n  }\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n  let node = target._sources;\n  let head = undefined;\n\n  /**\n   * At this point 'target._sources' points to the tail of the doubly-linked list.\n   * It contains all existing sources + new sources in order of use.\n   * Iterate backwards until we find the head node while dropping old dependencies.\n   */\n  while (node !== undefined) {\n    const prev = node._prevSource;\n\n    /**\n     * The node was not re-used, unsubscribe from its change notifications and remove itself\n     * from the doubly-linked list. e.g:\n     *\n     * { A <-> B <-> C }\n     *         \u2193\n     *    { A <-> C }\n     */\n    if (node._version === -1) {\n      node._source._unsubscribe(node);\n\n      if (prev !== undefined) {\n        prev._nextSource = node._nextSource;\n      }\n      if (node._nextSource !== undefined) {\n        node._nextSource._prevSource = prev;\n      }\n    } else {\n      /**\n       * The new head is the last node seen which wasn't removed/unsubscribed\n       * from the doubly-linked list. e.g:\n       *\n       * { A <-> B <-> C }\n       *   \u2191     \u2191     \u2191\n       *   \u2502     \u2502     \u2514 head = node\n       *   \u2502     \u2514 head = node\n       *   \u2514 head = node\n       */\n      head = node;\n    }\n\n    node._source._node = node._rollbackNode;\n    if (node._rollbackNode !== undefined) {\n      node._rollbackNode = undefined;\n    }\n\n    node = prev;\n  }\n\n  target._sources = head;\n}\n\ndeclare class Computed<T = any> extends Signal<T> {\n  _fn: () => T;\n  _sources?: Node;\n  _globalVersion: number;\n  _flags: number;\n\n  constructor(fn: () => T);\n\n  _notify(): void;\n  get value(): T;\n}\n\nfunction Computed(this: Computed, fn: () => unknown) {\n  Signal.call(this, undefined);\n\n  this._fn = fn;\n  this._sources = undefined;\n  this._globalVersion = globalVersion - 1;\n  this._flags = OUTDATED;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n  this._flags &= ~NOTIFIED;\n\n  if (this._flags & RUNNING) {\n    return false;\n  }\n\n  // If this computed signal has subscribed to updates from its dependencies\n  // (TRACKING flag set) and none of them have notified about changes (OUTDATED\n  // flag not set), then the computed value can't have changed.\n  if ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n    return true;\n  }\n  this._flags &= ~OUTDATED;\n\n  if (this._globalVersion === globalVersion) {\n    return true;\n  }\n  this._globalVersion = globalVersion;\n\n  // Mark this computed signal running before checking the dependencies for value\n  // changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n  this._flags |= RUNNING;\n  if (this._version > 0 && !needsToRecompute(this)) {\n    this._flags &= ~RUNNING;\n    return true;\n  }\n\n  const prevContext = evalContext;\n  try {\n    prepareSources(this);\n    evalContext = this;\n    const value = this._fn();\n    if (\n      this._flags & HAS_ERROR ||\n      this._value !== value ||\n      this._version === 0\n    ) {\n      this._value = value;\n      this._flags &= ~HAS_ERROR;\n      this._version++;\n    }\n  } catch (err) {\n    this._value = err;\n    this._flags |= HAS_ERROR;\n    this._version++;\n  }\n  evalContext = prevContext;\n  cleanupSources(this);\n  this._flags &= ~RUNNING;\n  return true;\n};\n\nComputed.prototype._subscribe = function (node) {\n  if (this._targets === undefined) {\n    this._flags |= OUTDATED | TRACKING;\n\n    // A computed signal subscribes lazily to its dependencies when it\n    // gets its first subscriber.\n    for (\n      let node = this._sources;\n      node !== undefined;\n      node = node._nextSource\n    ) {\n      node._source._subscribe(node);\n    }\n  }\n  Signal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the computed signal has any subscribers.\n  if (this._targets !== undefined) {\n    Signal.prototype._unsubscribe.call(this, node);\n\n    // Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n    // This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n    if (this._targets === undefined) {\n      this._flags &= ~TRACKING;\n\n      for (\n        let node = this._sources;\n        node !== undefined;\n        node = node._nextSource\n      ) {\n        node._source._unsubscribe(node);\n      }\n    }\n  }\n};\n\nComputed.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= OUTDATED | NOTIFIED;\n\n    for (\n      let node = this._targets;\n      node !== undefined;\n      node = node._nextTarget\n    ) {\n      node._target._notify();\n    }\n  }\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n  get(this: Computed) {\n    if (this._flags & RUNNING) {\n      throw new Error(\"Cycle detected\");\n    }\n    const node = addDependency(this);\n    this._refresh();\n    if (node !== undefined) {\n      node._version = this._version;\n    }\n    if (this._flags & HAS_ERROR) {\n      throw this._value;\n    }\n    return this._value;\n  },\n});\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n  readonly value: T;\n  peek(): T;\n\n  subscribe(fn: (value: T) => void): () => void;\n  valueOf(): T;\n  toString(): string;\n  toJSON(): T;\n  brand: typeof BRAND_SYMBOL;\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(fn: () => T): ReadonlySignal<T> {\n  return new Computed(fn);\n}\n\nfunction cleanupEffect(effect: Effect) {\n  const cleanup = effect._cleanup;\n  effect._cleanup = undefined;\n\n  if (typeof cleanup === \"function\") {\n    /*@__INLINE__**/ startBatch();\n\n    // Run cleanup functions always outside of any context.\n    const prevContext = evalContext;\n    evalContext = undefined;\n    try {\n      cleanup();\n    } catch (err) {\n      effect._flags &= ~RUNNING;\n      effect._flags |= DISPOSED;\n      disposeEffect(effect);\n      throw err;\n    } finally {\n      evalContext = prevContext;\n      endBatch();\n    }\n  }\n}\n\nfunction disposeEffect(effect: Effect) {\n  for (\n    let node = effect._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    node._source._unsubscribe(node);\n  }\n  effect._fn = undefined;\n  effect._sources = undefined;\n\n  cleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n  if (evalContext !== this) {\n    throw new Error(\"Out-of-order effect\");\n  }\n  cleanupSources(this);\n  evalContext = prevContext;\n\n  this._flags &= ~RUNNING;\n  if (this._flags & DISPOSED) {\n    disposeEffect(this);\n  }\n  endBatch();\n}\n\ntype EffectFn = () => void | (() => void);\n\ndeclare class Effect {\n  _fn?: EffectFn;\n  _cleanup?: () => void;\n  _sources?: Node;\n  _nextBatchedEffect?: Effect;\n  _flags: number;\n\n  constructor(fn: EffectFn);\n\n  _callback(): void;\n  _start(): () => void;\n  _notify(): void;\n  _dispose(): void;\n}\n\nfunction Effect(this: Effect, fn: EffectFn) {\n  this._fn = fn;\n  this._cleanup = undefined;\n  this._sources = undefined;\n  this._nextBatchedEffect = undefined;\n  this._flags = TRACKING;\n}\n\nEffect.prototype._callback = function () {\n  const finish = this._start();\n  try {\n    if (this._flags & DISPOSED) return;\n    if (this._fn === undefined) return;\n\n    const cleanup = this._fn();\n    if (typeof cleanup === \"function\") {\n      this._cleanup = cleanup;\n    }\n  } finally {\n    finish();\n  }\n};\n\nEffect.prototype._start = function () {\n  if (this._flags & RUNNING) {\n    throw new Error(\"Cycle detected\");\n  }\n  this._flags |= RUNNING;\n  this._flags &= ~DISPOSED;\n  cleanupEffect(this);\n  prepareSources(this);\n\n  /*@__INLINE__**/ startBatch();\n  const prevContext = evalContext;\n  evalContext = this;\n  return endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= NOTIFIED;\n    this._nextBatchedEffect = batchedEffect;\n    batchedEffect = this;\n  }\n};\n\nEffect.prototype._dispose = function () {\n  this._flags |= DISPOSED;\n\n  if (!(this._flags & RUNNING)) {\n    disposeEffect(this);\n  }\n};\n\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn): () => void {\n  const effect = new Effect(fn);\n  try {\n    effect._callback();\n  } catch (err) {\n    effect._dispose();\n    throw err;\n  }\n  // Return a bound function instead of a wrapper like `() => effect._dispose()`,\n  // because bound functions seem to be just as fast and take up a lot less memory.\n  return effect._dispose.bind(effect);\n}\n\nexport { batch, computed, effect, Signal, untracked };\nexport type { ReadonlySignal };\n", "// From https://github.com/EthanStandel/deepsignal/blob/main/packages/core/src/core.ts\nimport { Signal, batch, signal } from './preact-core'\n\nexport type AtomicState =\n  | Array<unknown>\n  | ((...args: unknown[]) => unknown)\n  | string\n  | boolean\n  | number\n  | bigint\n  | symbol\n  | undefined\n  | null\n\nexport type DeepState = {\n  [key: string]: (() => unknown) | AtomicState | DeepState\n}\n\nexport type ReadOnlyDeep<T> = {\n  readonly [P in keyof T]: ReadOnlyDeep<T[P]>\n}\n\nexport interface DeepSignalAccessors<T extends DeepState> {\n  value: ReadOnlyDeep<T>\n  peek: () => ReadOnlyDeep<T>\n}\n\nexport type DeepSignalType<T extends DeepState> = DeepSignalAccessors<T> & {\n  [K in keyof T]: T[K] extends AtomicState ? Signal<T[K]> : T[K] extends DeepState ? DeepSignalType<T[K]> : Signal<T[K]>\n}\n\nexport class DeepSignal<T extends DeepState> implements DeepSignalAccessors<T> {\n  get value(): ReadOnlyDeep<T> {\n    return getValue(this as DeepSignalType<T>)\n  }\n\n  set value(payload: ReadOnlyDeep<T>) {\n    batch(() => setValue(this as DeepSignalType<T>, payload))\n  }\n\n  peek(): ReadOnlyDeep<T> {\n    return getValue(this as DeepSignalType<T>, { peek: true })\n  }\n}\n\nexport const deepSignal = <T extends DeepState>(initialValue: T): DeepSignalType<T> =>\n  Object.assign(\n    new DeepSignal(),\n    Object.entries(initialValue).reduce(\n      (acc, [key, value]) => {\n        if (['value', 'peek'].some((iKey) => iKey === key)) {\n          throw new Error(`${key} is a reserved property name`)\n        } else if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n          acc[key] = signal(value)\n        } else {\n          acc[key] = deepSignal(value)\n        }\n        return acc\n      },\n      {} as { [key: string]: unknown },\n    ),\n  ) as DeepSignalType<T>\n\nconst setValue = <U extends DeepState, T extends DeepSignalType<U>>(deepSignal: T, payload: U): void =>\n  Object.keys(payload).forEach((key: keyof U) => (deepSignal[key].value = payload[key]))\n\nconst getValue = <U extends DeepState, T extends DeepSignalType<U>>(\n  deepSignal: T,\n  { peek = false }: { peek?: boolean } = {},\n): ReadOnlyDeep<U> =>\n  Object.entries(deepSignal).reduce(\n    (acc, [key, value]) => {\n      if (value instanceof Signal) {\n        acc[key] = peek ? value.peek() : value.value\n      } else if (value instanceof DeepSignal) {\n        acc[key] = getValue(value as DeepSignalType<DeepState>, { peek })\n      }\n      return acc\n    },\n    {} as { [key: string]: unknown },\n  ) as ReadOnlyDeep<U>\n", "// From https://github.com/riagominota/ts-merge-patch/blob/main/src/index.ts\n\ntype mpObj<T> = { [k in keyof T | string | number | symbol]: any };\nexport function apply<L, R>(\n  target: mpObj<L>,\n  patchItem: mpObj<R>,\n): Partial<L> & Partial<R>;\nexport function apply<L, R>(target: mpObj<L>, patchItem: mpObj<R>): R;\nexport function apply<L, R>(target: mpObj<L>, patchItem: mpObj<R>): {};\nexport function apply<L, R>(target: mpObj<L>, patchItem: null): null;\nexport function apply<L, R>(target: mpObj<L>, patchItem: string): string;\nexport function apply<L, R>(target: mpObj<L>, patchItem: number): number;\nexport function apply<L, R>(target: mpObj<L>, patchItem: undefined): undefined;\nexport function apply<L, R>(target: mpObj<L>, patchItem: R[]): R[];\n\nexport function apply(target: any, patchItem: any): any {\n  /**\n   * If the patch is anything other than an object,\n   * the result will always be to replace\n   * the entire target with the entire patch.\n   */\n  if (typeof patchItem !== \"object\" || Array.isArray(patchItem) || !patchItem) {\n    return JSON.parse(JSON.stringify(patchItem)); //return new instance of variable\n  }\n\n  if (\n    typeof patchItem === \"object\" &&\n    patchItem.toJSON !== undefined &&\n    typeof patchItem.toJSON === \"function\"\n  ) {\n    return patchItem.toJSON();\n  }\n  /** Also, it is not possible to\n   * patch part of a target that is not an object,\n   * such as to replace just some of the values in an array.\n   */\n  let targetResult = target;\n  if (typeof target !== \"object\") {\n    //Target is empty/not an object, so basically becomes patch, minus any null valued sections (becomes {} + patch)\n    targetResult = { ...patchItem };\n  }\n\n  Object.keys(patchItem).forEach((k) => {\n    if (!targetResult.hasOwnProperty(k)) targetResult[k] = patchItem[k]; //This ensure the key exists and TS can't throw a wobbly over an undefined key\n    if (patchItem[k] === null) {\n      delete targetResult[k];\n    } else {\n      targetResult[k] = apply(targetResult[k], patchItem[k]);\n    }\n  });\n  return targetResult;\n}\n", "export const DATASTAR = \"datastar\";\nexport const DATASTAR_EVENT = `${DATASTAR}-event`;\n", "export const VERSION = '0.20.0';\n", "import { elemToSelector, nodeHTMLorSVGElement } from \"../utils/dom\";\nimport { HTMLorSVGElement } from \"../utils/types\";\nimport { DeepSignal, deepSignal, DeepState } from \"../vendored/deepsignal\";\nimport { computed, effect, Signal, signal } from \"../vendored/preact-core\";\nimport { apply } from \"../vendored/ts-merge-patch\";\nimport { DATASTAR_EVENT } from \"./const\";\nimport {\n    ActionPlugin,\n    ActionPlugins,\n    AttribtueExpressionFunction,\n    AttributeContext,\n    AttributePlugin,\n    DatastarEvent,\n    DatastarPlugin,\n    InitContext,\n    OnRemovalFn,\n    PreprocessorPlugin,\n    Reactivity,\n    WatcherPlugin,\n} from \"./types\";\nimport { VERSION } from \"./version\";\n\nconst isPreprocessorPlugin = (p: DatastarPlugin): p is PreprocessorPlugin =>\n    p.pluginType === \"preprocessor\";\nconst isEffectPlugin = (p: DatastarPlugin): p is WatcherPlugin =>\n    p.pluginType === \"effect\";\nconst isAttributePlugin = (p: DatastarPlugin): p is AttributePlugin =>\n    p.pluginType === \"attribute\";\nconst isActionPlugin = (p: DatastarPlugin): p is ActionPlugin =>\n    p.pluginType === \"action\";\n\nexport class Engine {\n    plugins: AttributePlugin[] = [];\n    store: DeepSignal<any> = deepSignal({ _dsPlugins: {} });\n    preprocessors = new Array<PreprocessorPlugin>();\n    actions: ActionPlugins = {};\n    watchers = new Array<WatcherPlugin>();\n    refs: Record<string, HTMLElement> = {};\n    reactivity: Reactivity = {\n        signal,\n        computed,\n        effect,\n    };\n    parentID = \"\";\n    missingIDNext = 0;\n    removals = new Map<Element, { id: string; set: Set<OnRemovalFn> }>();\n    mergeRemovals = new Array<OnRemovalFn>();\n\n    constructor() {\n        // this.actions = Object.assign(this.actions, actions);\n        // plugins = [...CorePlugins, ...plugins];\n        // if (!plugins.length) throw new Error(\"No plugins provided\");\n\n        const observer = new MutationObserver(\n            (_mutationList, _observer) => {\n                this.sendDatastarEvent(\n                    \"core\",\n                    \"dom\",\n                    \"mutation\",\n                    document.body,\n                    document.body.outerHTML,\n                );\n            },\n        );\n\n        // Start observing the target node for configured mutations\n        observer.observe(document.body, {\n            attributes: true,\n            childList: true,\n            subtree: true,\n        });\n    }\n\n    get version() {\n        return VERSION;\n    }\n\n    load(...pluginsToLoad: DatastarPlugin[]) {\n        const allLoadedPlugins = new Set<DatastarPlugin>(this.plugins);\n\n        pluginsToLoad.forEach((plugin) => {\n            if (plugin.requiredPlugins) {\n                for (\n                    const requiredPluginType of plugin\n                        .requiredPlugins\n                ) {\n                    if (\n                        !allLoadedPlugins.has(requiredPluginType)\n                    ) {\n                        throw new Error(\n                            `Plugin '${plugin.name}' requires plugin '${requiredPluginType}' to be loaded`,\n                        );\n                    }\n                }\n            }\n\n            let globalInitializer: ((ctx: InitContext) => void) | undefined;\n            if (isPreprocessorPlugin(plugin)) {\n                if (this.preprocessors.includes(plugin)) {\n                    throw new Error(\n                        `Preprocessor ${plugin.name} already exists`,\n                    );\n                }\n                this.preprocessors.push(plugin);\n            } else if (isEffectPlugin(plugin)) {\n                if (this.watchers.includes(plugin)) {\n                    throw new Error(\n                        `Watcher ${plugin.name} already exists`,\n                    );\n                }\n                this.watchers.push(plugin);\n                globalInitializer = plugin.onGlobalInit;\n            } else if (isActionPlugin(plugin)) {\n                if (!!this.actions[plugin.name]) {\n                    throw new Error(\n                        `Action ${plugin.name} already exists`,\n                    );\n                }\n                this.actions[plugin.name] = plugin;\n            } else if (isAttributePlugin(plugin)) {\n                if (this.plugins.includes(plugin)) {\n                    throw new Error(\n                        `Attribute ${plugin.name} already exists`,\n                    );\n                }\n                this.plugins.push(plugin);\n                globalInitializer = plugin.onGlobalInit;\n            } else {\n                throw new Error(`Unknown plugin type: ${plugin}`);\n            }\n\n            if (globalInitializer) {\n                globalInitializer({\n                    store: this.store,\n                    upsertIfMissingFromStore: this.upsertIfMissingFromStore\n                        .bind(this),\n                    mergeStore: this.mergeStore.bind(this),\n                    removeFromStore: this.removeFromStore.bind(this),\n                    actions: this.actions,\n                    reactivity: this.reactivity,\n                    applyPlugins: this.applyPlugins.bind(this),\n                    cleanupElementRemovals: this.cleanupElementRemovals.bind(\n                        this,\n                    ),\n                    sendDatastarEvent: this.sendDatastarEvent.bind(this),\n                });\n            }\n\n            this.sendDatastarEvent(\n                \"core\",\n                \"plugins\",\n                \"registration\",\n                \"BODY\",\n                `On prefix ${plugin.name}`,\n            );\n\n            allLoadedPlugins.add(plugin);\n        });\n\n        this.applyPlugins(document.body);\n    }\n\n    private sendDatastarEvent(\n        category: \"core\" | \"plugin\",\n        subcategory: string,\n        type: string,\n        target: Element | Document | Window | string,\n        message: string,\n        opts: CustomEventInit = {\n            bubbles: true,\n            cancelable: true,\n            composed: true,\n        },\n    ) {\n        const contents = Object.assign(\n            {\n                detail: {\n                    time: new Date(),\n                    category,\n                    subcategory,\n                    type,\n                    target: elemToSelector(target),\n                    message,\n                },\n            },\n            opts,\n        );\n        const evt = new CustomEvent<DatastarEvent>(DATASTAR_EVENT, contents);\n        // console.log(\"Sending Datastar event\", evt);\n        window.dispatchEvent(evt);\n    }\n\n    private cleanupElementRemovals(element: Element) {\n        const removalSet = this.removals.get(element);\n        if (removalSet) {\n            for (const removal of removalSet.set) {\n                removal();\n            }\n            this.removals.delete(element);\n        }\n    }\n\n    lastMarshalledStore = \"\";\n    private mergeStore<T extends object>(mergeStore: T) {\n        this.mergeRemovals.forEach((removal) => removal());\n        this.mergeRemovals = this.mergeRemovals.slice(0);\n\n        const revisedStore = apply(this.store.value, mergeStore) as DeepState;\n        this.store = deepSignal(revisedStore);\n\n        const marshalledStore = JSON.stringify(this.store.value);\n        if (marshalledStore === this.lastMarshalledStore) return;\n\n        this.sendDatastarEvent(\n            \"core\",\n            \"store\",\n            \"merged\",\n            \"STORE\",\n            marshalledStore,\n        );\n    }\n\n    private removeFromStore(...keys: string[]) {\n        const revisedStore = { ...this.store.value };\n        for (const key of keys) {\n            const parts = key.split(\".\");\n            let currentID = parts[0];\n            let subStore = revisedStore;\n            for (let i = 1; i < parts.length; i++) {\n                const part = parts[i];\n                if (!subStore[currentID]) {\n                    subStore[currentID] = {};\n                }\n                subStore = subStore[currentID];\n                currentID = part;\n            }\n            delete subStore[currentID];\n        }\n        this.store = deepSignal(revisedStore);\n        this.applyPlugins(document.body);\n    }\n\n    private upsertIfMissingFromStore(path: string, value: any) {\n        const parts = path.split(\".\");\n        let subStore = this.store as any;\n        for (let i = 0; i < parts.length - 1; i++) {\n            const part = parts[i];\n            if (!subStore[part]) {\n                subStore[part] = {};\n            }\n            subStore = subStore[part];\n        }\n        const last = parts[parts.length - 1];\n        if (!!subStore[last]) return;\n        subStore[last] = this.reactivity.signal(value);\n        this.sendDatastarEvent(\"core\", \"store\", \"upsert\", path, value);\n    }\n\n    signalByName<T>(name: string) {\n        return (this.store as any)[name] as Signal<T>;\n    }\n\n    private applyPlugins(rootElement: Element) {\n        const appliedProcessors = new Set<PreprocessorPlugin>();\n\n        this.plugins.forEach((p, pi) => {\n            this.walkDownDOM(rootElement, (el) => {\n                if (!pi) this.cleanupElementRemovals(el);\n\n                for (const rawKey in el.dataset) {\n                    const rawExpression = `${el.dataset[rawKey]}` || \"\";\n                    let expression = rawExpression;\n\n                    if (!rawKey.startsWith(p.name)) continue;\n\n                    if (el.id.length === 0) {\n                        el.id = `ds-${this.parentID}-${this.missingIDNext++}`;\n                    }\n\n                    appliedProcessors.clear();\n\n                    if (p.allowedTagRegexps) {\n                        const lowerCaseTag = el.tagName.toLowerCase();\n                        const allowed = [...p.allowedTagRegexps].some((r) =>\n                            lowerCaseTag.match(r)\n                        );\n                        if (!allowed) {\n                            throw new Error(\n                                `'${el.tagName}' not allowed for '${rawKey}', allowed ${\n                                    [\n                                        [...p.allowedTagRegexps].map((t) =>\n                                            `'${t}'`\n                                        ),\n                                    ].join(\", \")\n                                }`,\n                            );\n                        }\n                    }\n\n                    let keyRaw = rawKey.slice(p.name.length);\n                    let [key, ...modifiersWithArgsArr] = keyRaw.split(\".\");\n                    if (p.mustHaveEmptyKey && key.length > 0) {\n                        throw new Error(`'${rawKey}' must have empty key`);\n                    }\n                    if (p.mustNotEmptyKey && key.length === 0) {\n                        throw new Error(`'${rawKey}' must have non-empty key`);\n                    }\n                    if (key.length) {\n                        key = key[0].toLowerCase() + key.slice(1);\n                    }\n\n                    const modifiersArr = modifiersWithArgsArr.map((m) => {\n                        const [label, ...args] = m.split(\"_\");\n                        return { label, args };\n                    });\n                    if (p.allowedModifiers) {\n                        for (const modifier of modifiersArr) {\n                            if (!p.allowedModifiers.has(modifier.label)) {\n                                throw new Error(\n                                    `'${modifier.label}' is not allowed`,\n                                );\n                            }\n                        }\n                    }\n                    const modifiers = new Map<string, string[]>();\n                    for (const modifier of modifiersArr) {\n                        modifiers.set(modifier.label, modifier.args);\n                    }\n\n                    if (p.mustHaveEmptyExpression && expression.length) {\n                        throw new Error(\n                            `'${rawKey}' must have empty expression`,\n                        );\n                    }\n                    if (p.mustNotEmptyExpression && !expression.length) {\n                        throw new Error(\n                            `'${rawKey}' must have non-empty expression`,\n                        );\n                    }\n\n                    const splitRegex = /;|\\n/;\n\n                    if (p.removeNewLines) {\n                        expression = expression\n                            .split(\"\\n\")\n                            .map((p: string) => p.trim())\n                            .join(\" \");\n                    }\n\n                    const processors = [\n                        ...(p.preprocessors?.pre || []),\n                        ...this.preprocessors,\n                        ...(p.preprocessors?.post || []),\n                    ];\n                    for (const processor of processors) {\n                        if (appliedProcessors.has(processor)) continue;\n                        appliedProcessors.add(processor);\n\n                        const expressionParts = expression.split(splitRegex);\n                        const revisedParts: string[] = [];\n\n                        expressionParts.forEach((exp) => {\n                            let revised = exp;\n                            const matches = [\n                                ...revised.matchAll(processor.regexp),\n                            ];\n                            if (matches.length) {\n                                for (const match of matches) {\n                                    if (!match.groups) continue;\n                                    const { groups } = match;\n                                    const { whole } = groups;\n                                    revised = revised.replace(\n                                        whole,\n                                        processor.replacer(groups),\n                                    );\n                                }\n                            }\n                            revisedParts.push(revised);\n                        });\n                        // })\n\n                        expression = revisedParts.join(\"; \");\n                    }\n\n                    const ctx: AttributeContext = {\n                        store: () => this.store,\n                        mergeStore: this.mergeStore.bind(this),\n                        upsertIfMissingFromStore: this.upsertIfMissingFromStore\n                            .bind(this),\n                        removeFromStore: this.removeFromStore.bind(this),\n                        applyPlugins: this.applyPlugins.bind(this),\n                        cleanupElementRemovals: this.cleanupElementRemovals\n                            .bind(this),\n                        walkSignals: this.walkSignals.bind(this),\n                        actions: this.actions,\n                        reactivity: this.reactivity,\n                        el,\n                        rawKey,\n                        key,\n                        rawExpression,\n                        expression,\n                        expressionFn: () => {\n                            throw new Error(\"Expression function not created\");\n                        },\n                        modifiers,\n                        sendDatastarEvent: this.sendDatastarEvent.bind(this),\n                    };\n\n                    if (\n                        !p.bypassExpressionFunctionCreation?.(ctx) &&\n                        !p.mustHaveEmptyExpression && expression.length\n                    ) {\n                        const statements = expression\n                            .split(splitRegex)\n                            .map((s) => s.trim())\n                            .filter((s) => s.length);\n                        statements[statements.length - 1] = `return ${\n                            statements[statements.length - 1]\n                        }`;\n                        const joined = statements.map((s) => `  ${s}`).join(\n                            \";\\n\",\n                        );\n                        const fnContent = `\n  try {\n    const _datastarExpression = () => {\n  ${joined}\n    }\n    const _datastarReturnVal = _datastarExpression()\n    ctx.sendDatastarEvent('core', 'attributes', 'expr_eval', ctx.el, '${rawKey} equals ' + JSON.stringify(_datastarReturnVal))\n    return _datastarReturnVal\n  } catch (e) {\n   const msg = \\`\n  Error evaluating Datastar expression:\n  ${joined.replaceAll(\"`\", \"\\\\`\")}\n\n  Error: \\${e.message}\n\n  Check if the expression is valid before raising an issue.\n  \\`.trim()\n   ctx.sendDatastarEvent('core', 'attributes', 'expr_eval_err', ctx.el, msg)\n   console.error(msg)\n   debugger\n  }\n              `;\n\n                        /*sendDatastarEvent(\n                'core',\n                'attributes',\n                'expr_construction',\n                ctx.el,\n                `${rawKey}=\"${rawExpression}\" becomes: ${joined}`,\n              )*/\n                        try {\n                            const argumentNames = p.argumentNames || [];\n                            const fn = new Function(\n                                \"ctx\",\n                                ...argumentNames,\n                                fnContent,\n                            ) as AttribtueExpressionFunction;\n                            ctx.expressionFn = fn;\n                        } catch (e) {\n                            const err = new Error(\n                                `Error creating expression function for '${fnContent}', error: ${e}`,\n                            );\n                            this.sendDatastarEvent(\n                                \"core\",\n                                \"attributes\",\n                                \"expr_construction_err\",\n                                ctx.el,\n                                String(err),\n                            );\n                            console.error(err);\n                            debugger;\n                        }\n                    }\n\n                    const removal = p.onLoad(ctx);\n                    if (removal) {\n                        if (!this.removals.has(el)) {\n                            this.removals.set(el, {\n                                id: el.id,\n                                set: new Set(),\n                            });\n                        }\n                        this.removals.get(el)!.set.add(removal);\n                    }\n                }\n            });\n        });\n    }\n\n    private walkSignalsStore(\n        store: any,\n        callback: (name: string, signal: Signal<any>) => void,\n    ) {\n        const keys = Object.keys(store);\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            const value = store[key];\n            const isSignal = value instanceof Signal;\n            const hasChildren = typeof value === \"object\" &&\n                Object.keys(value).length > 0;\n\n            if (isSignal) {\n                callback(key, value);\n                continue;\n            }\n\n            if (!hasChildren) continue;\n\n            this.walkSignalsStore(value, callback);\n        }\n    }\n\n    private walkSignals(callback: (name: string, signal: Signal<any>) => void) {\n        this.walkSignalsStore(this.store, callback);\n    }\n\n    private walkDownDOM(\n        element: Element | null,\n        callback: (el: HTMLorSVGElement) => void,\n        siblingOffset = 0,\n    ) {\n        if (!element) return;\n        const el = nodeHTMLorSVGElement(element);\n        if (!el) return;\n\n        callback(el);\n\n        siblingOffset = 0;\n        element = element.firstElementChild;\n        while (element) {\n            this.walkDownDOM(element, callback, siblingOffset++);\n            element = element.nextElementSibling;\n        }\n    }\n}\n", "import { Computed } from \"../plugins/official/attributes/core/computed\";\nimport { Store } from \"../plugins/official/attributes/core/store\";\nimport { ActionsProcessor } from \"../plugins/official/preprocessors/core/actions\";\nimport { SignalsProcessor } from \"../plugins/official/preprocessors/core/signals\";\nimport { Engine } from \"./engine\";\n\nexport * from \"./const\";\nexport type * from \"./types\";\n\nconst ds = new Engine();\nds.load(\n    ActionsProcessor,\n    SignalsProcessor,\n    Store,\n    Computed,\n);\n\nexport const Datastar = ds;\n", "// Authors: Delaney Gillilan\n// Icon: carbon:fetch-upload\n// Slug: Check if a fetch request is currently in progress\n// Description: This action checks if a fetch request is currently in progress. This is useful for showing loading indicators or disabling buttons while a fetch request is in progress.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { IndicatorReference } from \"./sseShared\";\n\nexport const IsFetching: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"isFetching\",\n    method: (ctx, selector: string) => {\n        const indicators = [...document.querySelectorAll(selector)];\n        const store = ctx.store();\n        const indicatorsVisible: IndicatorReference[] =\n            store?._dsPlugins?.fetch.indicatorsVisible?.value || [];\n        if (!!!indicators.length) return false;\n\n        return indicators.some((indicator) => {\n            return indicatorsVisible\n                .filter((val) => !!val)\n                .some((indicatorVisible) => {\n                    return indicatorVisible.el.isSameNode(indicator) &&\n                        indicatorVisible.count > 0;\n                });\n        });\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:public\n// Slug: Filter to only signals that should be sent to the server\n// Description: This is a nested action that filters out signals that should not be sent to the server.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { remoteSignals } from \"../../../../utils/signals\";\n\nexport const RemoteSignals: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"remote\",\n    method: async (ctx) => {\n        return remoteSignals(ctx.store().value);\n    },\n};\n", "/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\nexport interface EventSourceMessage {\n    /** The event ID to set the EventSource object's last event ID value. */\n    id: string;\n    /** A string identifying the type of event described. */\n    event: string;\n    /** The event data */\n    data: string;\n    /** The reconnection interval (in milliseconds) to wait before retrying the connection */\n    retry?: number;\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nexport async function getBytes(\n    stream: ReadableStream<Uint8Array>,\n    onChunk: (arr: Uint8Array) => void,\n) {\n    const reader = stream.getReader();\n    let result: ReadableStreamReadResult<Uint8Array>;\n    while (!(result = await reader.read()).done) {\n        onChunk(result.value);\n    }\n}\n\nconst enum ControlChars {\n    NewLine = 10,\n    CarriageReturn = 13,\n    Space = 32,\n    Colon = 58,\n}\n\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nexport function getLines(\n    onLine: (line: Uint8Array, fieldLength: number) => void,\n) {\n    let buffer: Uint8Array | undefined;\n    let position: number; // current read position\n    let fieldLength: number; // length of the `field` portion of the line\n    let discardTrailingNewline = false;\n\n    // return a function that can process each incoming byte chunk:\n    return function onChunk(arr: Uint8Array) {\n        if (buffer === undefined) {\n            buffer = arr;\n            position = 0;\n            fieldLength = -1;\n        } else {\n            // we're still parsing the old line. Append the new bytes into buffer:\n            buffer = concat(buffer, arr);\n        }\n\n        const bufLength = buffer.length;\n        let lineStart = 0; // index where the current line starts\n        while (position < bufLength) {\n            if (discardTrailingNewline) {\n                if (buffer[position] === ControlChars.NewLine) {\n                    lineStart = ++position; // skip to next char\n                }\n\n                discardTrailingNewline = false;\n            }\n\n            // start looking forward till the end of line:\n            let lineEnd = -1; // index of the \\r or \\n char\n            for (; position < bufLength && lineEnd === -1; ++position) {\n                switch (buffer[position]) {\n                    case ControlChars.Colon:\n                        if (fieldLength === -1) { // first colon in line\n                            fieldLength = position - lineStart;\n                        }\n                        break;\n                    // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n                    case ControlChars.CarriageReturn:\n                        discardTrailingNewline = true;\n                    case ControlChars.NewLine:\n                        lineEnd = position;\n                        break;\n                }\n            }\n\n            if (lineEnd === -1) {\n                // We reached the end of the buffer but the line hasn't ended.\n                // Wait for the next arr and then continue parsing:\n                break;\n            }\n\n            // we've reached the line end, send it out:\n            onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n            lineStart = position; // we're now on the next line\n            fieldLength = -1;\n        }\n\n        if (lineStart === bufLength) {\n            buffer = undefined; // we've finished reading it\n        } else if (lineStart !== 0) {\n            // Create a new view into buffer beginning at lineStart so we don't\n            // need to copy over the previous lines when we get the new arr:\n            buffer = buffer.subarray(lineStart);\n            position -= lineStart;\n        }\n    };\n}\n\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nexport function getMessages(\n    onId: (id: string) => void,\n    onRetry: (retry: number) => void,\n    onMessage?: (msg: EventSourceMessage) => void,\n) {\n    let message = newMessage();\n    const decoder = new TextDecoder();\n\n    // return a function that can process each incoming line buffer:\n    return function onLine(line: Uint8Array, fieldLength: number) {\n        if (line.length === 0) {\n            // empty line denotes end of message. Trigger the callback and start a new message:\n            onMessage?.(message);\n            message = newMessage();\n        } else if (fieldLength > 0) { // exclude comments and lines with no values\n            // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n            // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n            const field = decoder.decode(line.subarray(0, fieldLength));\n            const valueOffset = fieldLength +\n                (line[fieldLength + 1] === ControlChars.Space ? 2 : 1);\n            const value = decoder.decode(line.subarray(valueOffset));\n\n            switch (field) {\n                case \"data\":\n                    // if this message already has data, append the new value to the old.\n                    // otherwise, just set to the new value:\n                    message.data = message.data\n                        ? message.data + \"\\n\" + value\n                        : value; // otherwise,\n                    break;\n                case \"event\":\n                    message.event = value;\n                    break;\n                case \"id\":\n                    onId(message.id = value);\n                    break;\n                case \"retry\":\n                    const retry = parseInt(value, 10);\n                    if (!isNaN(retry)) { // per spec, ignore non-integers\n                        onRetry(message.retry = retry);\n                    }\n                    break;\n            }\n        }\n    };\n}\n\nfunction concat(a: Uint8Array, b: Uint8Array) {\n    const res = new Uint8Array(a.length + b.length);\n    res.set(a);\n    res.set(b, a.length);\n    return res;\n}\n\nfunction newMessage(): EventSourceMessage {\n    // data, event, and id must be initialized to empty strings:\n    // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n    // retry should be initialized to undefined so we return a consistent shape\n    // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n    return {\n        data: \"\",\n        event: \"\",\n        id: \"\",\n        retry: undefined,\n    };\n}\n", "import { EventSourceMessage, getBytes, getLines, getMessages } from \"./parse\";\n\nexport const EventStreamContentType = \"text/event-stream\";\n\nconst DefaultRetryInterval = 1000;\nconst LastEventId = \"last-event-id\";\n\nexport interface FetchEventSourceInit extends RequestInit {\n    /**\n     * The request headers. FetchEventSource only supports the Record<string,string> format.\n     */\n    headers?: Record<string, string>;\n\n    /**\n     * Called when a response is received. Use this to validate that the response\n     * actually matches what you expect (and throw if it doesn't.) If not provided,\n     * will default to a basic validation to ensure the content-type is text/event-stream.\n     */\n    onopen?: (response: Response) => Promise<void>;\n\n    /**\n     * Called when a message is received. NOTE: Unlike the default browser\n     * EventSource.onmessage, this callback is called for _all_ events,\n     * even ones with a custom `event` field.\n     */\n    onmessage?: (ev: EventSourceMessage) => void;\n\n    /**\n     * Called when a response finishes. If you don't expect the server to kill\n     * the connection, you can throw an exception here and retry using onerror.\n     */\n    onclose?: () => void;\n\n    /**\n     * Called when there is any error making the request / processing messages /\n     * handling callbacks etc. Use this to control the retry strategy: if the\n     * error is fatal, rethrow the error inside the callback to stop the entire\n     * operation. Otherwise, you can return an interval (in milliseconds) after\n     * which the request will automatically retry (with the last-event-id).\n     * If this callback is not specified, or it returns undefined, fetchEventSource\n     * will treat every error as retriable and will try again after 1 second.\n     */\n    onerror?: (err: any) => number | null | undefined | void;\n\n    /**\n     * If true, will keep the request open even if the document is hidden.\n     * By default, fetchEventSource will close the request and reopen it\n     * automatically when the document becomes visible again.\n     */\n    openWhenHidden?: boolean;\n\n    /** The Fetch function to use. Defaults to window.fetch */\n    fetch?: typeof fetch;\n\n    /** The scaler for the retry interval. Defaults to 2 */\n    retryScaler?: number;\n\n    /** The maximum retry interval in milliseconds. Defaults to 30_000 */\n    retryMaxWaitMs?: number;\n\n    /** The maximum number of retries before giving up. Defaults to 10 */\n    retryMaxCount?: number;\n}\n\nexport function fetchEventSource(input: RequestInfo, {\n    signal: inputSignal,\n    headers: inputHeaders,\n    onopen: inputOnOpen,\n    onmessage,\n    onclose,\n    onerror,\n    openWhenHidden,\n    fetch: inputFetch,\n    retryScaler = 2,\n    retryMaxWaitMs = 30_000,\n    retryMaxCount = 10,\n    ...rest\n}: FetchEventSourceInit) {\n    return new Promise<void>((resolve, reject) => {\n        let retries = 0;\n\n        // make a copy of the input headers since we may modify it below:\n        const headers = { ...inputHeaders };\n        if (!headers.accept) {\n            headers.accept = EventStreamContentType;\n        }\n\n        let curRequestController: AbortController;\n        function onVisibilityChange() {\n            curRequestController.abort(); // close existing request on every visibility change\n            if (!document.hidden) {\n                create(); // page is now visible again, recreate request.\n            }\n        }\n\n        if (!openWhenHidden) {\n            document.addEventListener(\"visibilitychange\", onVisibilityChange);\n        }\n\n        let retryInterval = DefaultRetryInterval;\n        let retryTimer = 0;\n        function dispose() {\n            document.removeEventListener(\n                \"visibilitychange\",\n                onVisibilityChange,\n            );\n            window.clearTimeout(retryTimer);\n            curRequestController.abort();\n        }\n\n        // if the incoming signal aborts, dispose resources and resolve:\n        inputSignal?.addEventListener(\"abort\", () => {\n            dispose();\n            resolve(); // don't waste time constructing/logging errors\n        });\n\n        const fetch = inputFetch ?? window.fetch;\n        const onopen = inputOnOpen ?? defaultOnOpen;\n        async function create() {\n            curRequestController = new AbortController();\n            try {\n                const response = await fetch(input, {\n                    ...rest,\n                    headers,\n                    signal: curRequestController.signal,\n                });\n\n                await onopen(response);\n\n                await getBytes(\n                    response.body!,\n                    getLines(getMessages((id) => {\n                        if (id) {\n                            // store the id and send it back on the next retry:\n                            headers[LastEventId] = id;\n                        } else {\n                            // don't send the last-event-id header anymore:\n                            delete headers[LastEventId];\n                        }\n                    }, (retry) => {\n                        retryInterval = retry;\n                    }, onmessage)),\n                );\n\n                onclose?.();\n                dispose();\n                resolve();\n            } catch (err) {\n                if (!curRequestController.signal.aborted) {\n                    // if we haven't aborted the request ourselves:\n                    try {\n                        // check if we need to retry:\n                        const interval: any = onerror?.(err) ?? retryInterval;\n                        window.clearTimeout(retryTimer);\n                        retryTimer = window.setTimeout(create, interval);\n                        retryInterval *= retryScaler; // exponential backoff\n                        retryInterval = Math.min(retryInterval, retryMaxWaitMs);\n                        retries++;\n                        if (retries >= retryMaxCount) {\n                            // we should not retry anymore:\n                            dispose();\n                            reject(\n                                new Error(\n                                    `Max retries hit, check your server or network connection.`,\n                                ),\n                            );\n                        } else {\n                            console.error(\n                                `Error fetching event source, retrying in ${interval}ms`,\n                            );\n                        }\n                    } catch (innerErr) {\n                        // we should not retry anymore:\n                        dispose();\n                        reject(innerErr);\n                    }\n                }\n            }\n        }\n\n        create();\n    });\n}\n\nfunction defaultOnOpen(response: Response) {\n    const contentType = response.headers.get(\"content-type\");\n    if (!contentType?.startsWith(EventStreamContentType)) {\n        throw new Error(\n            `Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`,\n        );\n    }\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:network-wifi\n// Slug: Use a selector to show a loading indicator when fetching data from the server\n// Description: This plugin allows you to use a selector to show a loading indicator when fetching data from the server.  Once you add this attribute the indicator will be hidden by default and shown when the fetch is in progress.\n\nimport { AttributePlugin, DATASTAR } from \"../../../../engine\";\n\nexport const INDICATOR_CLASS = `${DATASTAR}-indicator`;\nexport const INDICATOR_LOADING_CLASS = `${INDICATOR_CLASS}-loading`;\n\n// Sets the fetch indicator selector\nexport const FetchIndicator: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"fetchIndicator\",\n    mustHaveEmptyKey: true,\n    mustNotEmptyExpression: true,\n    onGlobalInit: () => {\n        const style = document.createElement(\"style\");\n        style.innerHTML = `\n  .${INDICATOR_CLASS}{\n   opacity:0;\n   transition: opacity 300ms ease-out;\n  }\n  .${INDICATOR_LOADING_CLASS} {\n   opacity:1;\n   transition: opacity 300ms ease-in;\n  }\n  `;\n        document.head.appendChild(style);\n    },\n    onLoad: (ctx) => {\n        return ctx.reactivity.effect(() => {\n            ctx.upsertIfMissingFromStore(\n                \"_dsPlugins.fetch.indicatorElements\",\n                {},\n            );\n            ctx.upsertIfMissingFromStore(\n                \"_dsPlugins.fetch.indicatorsVisible\",\n                [],\n            );\n            const c = ctx.reactivity.computed(() => `${ctx.expressionFn(ctx)}`);\n            const s = ctx.store();\n\n            const indicators = document.querySelectorAll(c.value);\n            if (indicators.length === 0) {\n                throw new Error(`No indicator found`);\n            }\n            indicators.forEach((indicator) => {\n                indicator.classList.add(INDICATOR_CLASS);\n            });\n\n            s._dsPlugins.fetch.indicatorElements[ctx.el.id] = ctx.reactivity\n                .signal(indicators);\n\n            return () => {\n                delete s._dsPlugins.fetch.indicatorElements[ctx.el.id];\n            };\n        });\n    },\n};\n", "export const kebabize = (str: string) =>\n    str.replace(\n        /[A-Z]+(?![a-z])|[A-Z]/g,\n        ($, ofs) => (ofs ? \"-\" : \"\") + $.toLowerCase(),\n    );\n", "import { DATASTAR, InitContext } from \"../../../../engine\";\nimport { kebabize } from \"../../../../utils/text\";\n\nexport const DATASTAR_SSE_EVENT = \"datastar-sse\";\nexport const DEFAULT_SETTLE_DURATION_RAW = \"300\";\nexport const SETTLING_CLASS = `${DATASTAR}-settling`;\nexport const SWAPPING_CLASS = `${DATASTAR}-swapping`;\n\nexport interface DatastarSSEEvent {\n    type: string;\n    argsRaw: Record<string, string>;\n}\n\nexport interface CustomEventMap {\n    \"datastar-sse\": CustomEvent<DatastarSSEEvent>;\n}\n\ndeclare global {\n    interface Document { //adds definition to Document, but you can do the same with HTMLElement\n        addEventListener<K extends keyof CustomEventMap>(\n            type: K,\n            listener: (this: Document, ev: CustomEventMap[K]) => void,\n        ): void;\n        dispatchEvent<K extends keyof CustomEventMap>(\n            ev: CustomEventMap[K],\n        ): void;\n    }\n}\n\nexport function datastarSSEEventWatcher(\n    ctx: InitContext,\n    name: string,\n    fn: (argsRaw: Record<string, string>) => void,\n) {\n    const kebabName = kebabize(name);\n    document.addEventListener(\n        DATASTAR_SSE_EVENT,\n        (event: CustomEvent<DatastarSSEEvent>) => {\n            if (event.detail.type != kebabName) return;\n            const { argsRaw } = event.detail;\n            fn(argsRaw);\n\n            ctx.sendDatastarEvent(\n                \"plugin\",\n                \"backend\",\n                \"sse\",\n                name,\n                JSON.stringify(argsRaw),\n            );\n        },\n    );\n}\n", "import { ActionMethod, DATASTAR } from \"../../../../engine\";\nimport { remoteSignals } from \"../../../../utils/signals\";\nimport {\n    fetchEventSource,\n    FetchEventSourceInit,\n} from \"../../../../vendored/fetch-event-source\";\nimport { Signal } from \"../../../../vendored/preact-core\";\nimport {\n    INDICATOR_CLASS,\n    INDICATOR_LOADING_CLASS,\n} from \"../../attributes/backend/fetchIndicator\";\nimport {\n    DATASTAR_SSE_EVENT,\n    DatastarSSEEvent,\n    DEFAULT_SETTLE_DURATION_RAW,\n} from \"../../watchers/backend/sseShared\";\n\nexport type IndicatorReference = { el: HTMLElement; count: number };\n\nconst DEFAULT_SETTLE_DURATION = parseInt(DEFAULT_SETTLE_DURATION_RAW);\nconst isWrongContent = (err: any) =>\n    `${err}`.includes(\n        `Expected content-type to be text/event-stream`,\n    );\n\nexport function sendSSERequest(\n    method: string,\n): ActionMethod {\n    return async (ctx, url, onlyRemotes = true) => {\n        if (!!!url?.length) {\n            throw new Error(\"URL is required for SSE request\");\n        }\n\n        const currentStore = ctx.store().value;\n        let store = Object.assign({}, currentStore);\n        if (onlyRemotes) {\n            store = remoteSignals(store);\n        }\n        const storeJSON = JSON.stringify(store);\n\n        const sendFromElement = ctx.el as HTMLElement;\n        ctx.sendDatastarEvent(\n            \"plugin\",\n            \"backend\",\n            \"fetch_start\",\n            sendFromElement,\n            JSON.stringify({ method, url, onlyRemotes, storeJSON }),\n        );\n\n        const indicatorElements: HTMLElement[] =\n            store?._dsPlugins?.fetch?.indicatorElements\n                ? store?._dsPlugins?.fetch\n                    ?.indicatorElements?.[sendFromElement.id]\n                    ?.value || []\n                : [];\n        const indicatorsVisible: Signal<IndicatorReference[]> | undefined =\n            store\n                ?._dsPlugins?.fetch?.indicatorsVisible;\n\n        indicatorElements.forEach((indicator) => {\n            if (!indicator || !indicatorsVisible) {\n                return;\n            }\n            const indicatorVisibleIndex = indicatorsVisible.value.findIndex(\n                (indicatorVisible) => {\n                    if (!indicatorVisible) {\n                        return false;\n                    }\n                    return indicator.isSameNode(indicatorVisible.el);\n                },\n            );\n            if (indicatorVisibleIndex > -1) {\n                const indicatorVisible =\n                    indicatorsVisible.value[indicatorVisibleIndex];\n                const indicatorsVisibleNew = [...indicatorsVisible.value];\n                delete indicatorsVisibleNew[indicatorVisibleIndex];\n                indicatorsVisible.value = [\n                    ...indicatorsVisibleNew.filter((indicator) => {\n                        return !!indicator;\n                    }),\n                    { el: indicator, count: indicatorVisible.count + 1 },\n                ];\n            } else {\n                indicator.classList.remove(INDICATOR_CLASS);\n                indicator.classList.add(INDICATOR_LOADING_CLASS);\n                indicatorsVisible.value = [\n                    ...indicatorsVisible.value,\n                    {\n                        el: indicator,\n                        count: 1,\n                    },\n                ];\n            }\n        });\n\n        const urlInstance = new URL(url, window.location.origin);\n        const req: FetchEventSourceInit = {\n            method,\n            headers: {\n                [\"Content-Type\"]: \"application/json\",\n                [`${DATASTAR}-request`]: \"true\",\n            },\n            onmessage: (evt) => {\n                if (!evt.event.startsWith(DATASTAR)) {\n                    return;\n                }\n                const type = evt.event.slice(DATASTAR.length + 1);\n                const argsRawLines: Record<string, string[]> = {};\n\n                const lines = evt.data.split(\"\\n\");\n                for (const line of lines) {\n                    const colonIndex = line.indexOf(\" \");\n                    const key = line.slice(0, colonIndex);\n                    let argLines = argsRawLines[key];\n                    if (!argLines) {\n                        argLines = [];\n                        argsRawLines[key] = argLines;\n                    }\n                    const value = line.slice(colonIndex + 1).trim();\n                    argLines.push(value);\n                }\n\n                const argsRaw: Record<string, string> = {};\n                for (const [key, lines] of Object.entries(argsRawLines)) {\n                    argsRaw[key] = lines.join(\"\\n\");\n                }\n\n                // if you aren't seeing your event you can debug by using this line in the console\n                // document.addEventListener(\"datastar-sse\",(e) => console.log(e));\n\n                const datastarSSEEvent = new CustomEvent<DatastarSSEEvent>(\n                    DATASTAR_SSE_EVENT,\n                    {\n                        detail: { type, argsRaw },\n                    },\n                );\n                document.dispatchEvent(datastarSSEEvent);\n            },\n            onerror: (err) => {\n                if (isWrongContent(err)) {\n                    // don't retry if the content-type is wrong\n                    throw err;\n                }\n                // do nothing and it will retry\n                console.error(`Error with SSE request: ${err.message}`);\n            },\n            onclose: () => {\n                try {\n                    const store = ctx.store();\n                    const indicatorsVisible: Signal<IndicatorReference[]> =\n                        store?._dsPlugins?.fetch?.indicatorsVisible || [];\n                    const indicatorElements: HTMLElement[] =\n                        store?._dsPlugins?.fetch?.indicatorElements\n                            ? store._dsPlugins.fetch\n                                .indicatorElements[sendFromElement.id]?.value ||\n                                []\n                            : [];\n                    const indicatorCleanupPromises: Promise<() => void>[] = [];\n                    if (indicatorElements?.forEach) {\n                        indicatorElements.forEach((indicator) => {\n                            if (!indicator || !indicatorsVisible) {\n                                return;\n                            }\n                            const indicatorsVisibleNew =\n                                indicatorsVisible.value;\n                            const indicatorVisibleIndex = indicatorsVisibleNew\n                                .findIndex((indicatorVisible) => {\n                                    if (!indicatorVisible) {\n                                        return false;\n                                    }\n                                    return indicator.isSameNode(\n                                        indicatorVisible.el,\n                                    );\n                                });\n                            const indicatorVisible =\n                                indicatorsVisibleNew[indicatorVisibleIndex];\n                            if (!indicatorVisible) {\n                                return;\n                            }\n                            if (indicatorVisible.count < 2) {\n                                indicatorCleanupPromises.push(\n                                    new Promise(() =>\n                                        setTimeout(() => {\n                                            indicator.classList.remove(\n                                                INDICATOR_LOADING_CLASS,\n                                            );\n                                            indicator.classList.add(\n                                                INDICATOR_CLASS,\n                                            );\n                                        }, DEFAULT_SETTLE_DURATION)\n                                    ),\n                                );\n                                delete indicatorsVisibleNew[\n                                    indicatorVisibleIndex\n                                ];\n                            } else if (indicatorVisibleIndex > -1) {\n                                indicatorsVisibleNew[indicatorVisibleIndex]\n                                    .count = indicatorsVisibleNew[\n                                        indicatorVisibleIndex\n                                    ]\n                                        .count - 1;\n                            }\n                            indicatorsVisible.value = indicatorsVisibleNew\n                                .filter(\n                                    (indicator) => {\n                                        return !!indicator;\n                                    },\n                                );\n                        });\n                    }\n\n                    Promise.all(indicatorCleanupPromises);\n                } catch (e) {\n                    console.error(e);\n                    debugger;\n                } finally {\n                    ctx.sendDatastarEvent(\n                        \"plugin\",\n                        \"backend\",\n                        \"fetch_end\",\n                        sendFromElement,\n                        JSON.stringify({ method, url }),\n                    );\n                }\n            },\n        };\n\n        if (method === \"GET\") {\n            const queryParams = new URLSearchParams(urlInstance.search);\n            queryParams.append(\"datastar\", storeJSON);\n            urlInstance.search = queryParams.toString();\n        } else {\n            req.body = storeJSON;\n        }\n\n        const headers = store?._dsPlugins?.fetch?.headers || {};\n        if (req.headers) {\n            for (const [key, value] of Object.entries(headers)) {\n                if (key.startsWith(\"_\")) {\n                    continue;\n                }\n                req.headers[key] = `${value}`;\n            }\n        }\n\n        try {\n            const revisedURL = urlInstance.toString();\n            await fetchEventSource(revisedURL, req);\n        } catch (err) {\n            if (!isWrongContent(err)) {\n                throw new Error(`Failed to fetch ${url}: ${err}`);\n            }\n\n            // exit gracefully and do nothing if the content-type is wrong\n            // this can happen if the client is sending a request\n            // where no response is expected, and they haven't\n            // set the content-type to text/event-stream\n        }\n    };\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:delete\n// Slug: Use a DELETE request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { sendSSERequest } from \"./sseShared\";\n\nexport const DeleteSSE: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"delete\",\n    method: sendSSERequest(\"DELETE\"),\n};\n", "// Authors: Delaney Gillilan\n// Icon: ic:baseline-get-app\n// Slug: Use a GET request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { sendSSERequest } from \"./sseShared\";\n\nexport const GetSSE: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"get\",\n    method: sendSSERequest(\"GET\"),\n};\n", "// Authors: Delaney Gillilan\n// Icon: mdi:bandage\n// Slug: Use a PATCH request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { sendSSERequest } from \"./sseShared\";\n\nexport const PatchSSE: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"patch\",\n    method: sendSSERequest(\"PATCH\"),\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:add\n// Slug: Use a POST request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { sendSSERequest } from \"./sseShared\";\n\nexport const PostSSE: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"post\",\n    method: sendSSERequest(\"POST\"),\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:find-replace\n// Slug: Use a PUT request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { sendSSERequest } from \"./sseShared\";\n\nexport const PutSSE: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"put\",\n    method: sendSSERequest(\"PUT\"),\n};\n", "// Authors: Delaney Gillilan\n// Icon: mdi:clipboard\n// Slug: Copy text to the clipboard\n// Description: This action copies text to the clipboard using the Clipboard API.\n\nimport { ActionPlugin } from \"../../../../engine\";\n\nexport const Clipboard: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"clipboard\",\n    method: (_, text) => {\n        if (!navigator.clipboard) {\n            throw new Error(\"Clipboard API not available\");\n        }\n        navigator.clipboard.writeText(text);\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: mdi:cursor-pointer\n// Slug: Reference an element\n// Description: This action references an element that can be used in other expressions.\n\nimport { ActionPlugin } from \"../../../../engine\";\n\nexport const RefAction: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"ref\",\n    method: (ctx, text) => {\n        const selectorSignal = ctx.store()?._dsPlugins?.refs?.[text];\n        if (!selectorSignal) {\n            throw new Error(`Reference '${text}' not found`);\n        }\n        const selector = selectorSignal?.value;\n        if (!selector) {\n            throw new Error(`Selector '${selector}' not found`);\n        }\n\n        const el = document.querySelector(selector);\n        if (!el) {\n            throw new Error(`Elements for selector '${selector}' not found`);\n        }\n\n        return el;\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: ion:checkmark-round\n// Slug: Set all signals that match a regular expression\n\nimport { ActionPlugin } from \"../../../../engine\";\n\nexport const SetAll: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"setAll\",\n    method: (ctx, regexp, newValue) => {\n        const re = new RegExp(regexp);\n        ctx.walkSignals((name, signal) =>\n            re.test(name) && (signal.value = newValue)\n        );\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:toggle-off\n// Slug: Toggle all signals that match a regular expression\n\nimport { ActionPlugin } from \"../../../../engine\";\n\nexport const ToggleAll: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"toggleAll\",\n    method: (ctx, regexp) => {\n        const re = new RegExp(regexp);\n        ctx.walkSignals((name, signal) =>\n            re.test(name) && (signal.value = !signal.value)\n        );\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:fit-screen-outline\n// Slug: Clamp a value to a new range\n// Description: This action clamps a value to a new range. The value is first scaled to the new range, then clamped to the new range. This is useful for scaling a value to a new range, then clamping it to that range.\n\nimport { ActionPlugin, AttributeContext } from \"../../../../engine\";\n\nexport const ClampFit: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"clampFit\",\n    method: (\n        _: AttributeContext,\n        v: number,\n        oldMin: number,\n        oldMax: number,\n        newMin: number,\n        newMax: number,\n    ) => {\n        return Math.max(\n            newMin,\n            Math.min(\n                newMax,\n                ((v - oldMin) / (oldMax - oldMin)) * (newMax - newMin) + newMin,\n            ),\n        );\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:fit-screen\n// Slug: Clamp a value to a new range and round to the nearest integer\n// Description: This action clamps a value to a new range. The value is first scaled to the new range, then clamped to the new range. This is useful for scaling a value to a new range, then clamping it to that range. The result is then rounded to the nearest integer.\n\nimport { ActionPlugin, AttributeContext } from \"../../../../engine\";\n\nexport const ClampFitInt: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"clampFitInt\",\n    method: (\n        _: AttributeContext,\n        v: number,\n        oldMin: number,\n        oldMax: number,\n        newMin: number,\n        newMax: number,\n    ) => {\n        return Math.round(\n            Math.max(\n                newMin,\n                Math.min(\n                    newMax,\n                    ((v - oldMin) / (oldMax - oldMin)) * (newMax - newMin) +\n                        newMin,\n                ),\n            ),\n        );\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols-light:fit-width\n// Slug: Linearly fit a value to a new range\n// Description: This action linearly fits a value to a new range. The value is first scaled to the new range.  Note it is not clamped to the new range.\n\nimport { ActionPlugin, AttributeContext } from \"../../../../engine\";\n\nexport const Fit: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"fit\",\n    method: (\n        _: AttributeContext,\n        v: number,\n        oldMin: number,\n        oldMax: number,\n        newMin: number,\n        newMax: number,\n    ) => {\n        return ((v - oldMin) / (oldMax - oldMin)) * (newMax - newMin) + newMin;\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:fit-width\n// Slug: Linearly fit a value to a new range and round to the nearest integer\n// Description: This action linearly fits a value to a new range. The value is first scaled to the new range.  Note it is not clamped to the new range.\n\nimport { ActionPlugin, AttributeContext } from \"../../../../engine\";\n\nexport const FitInt: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"fitInt\",\n    method: (\n        _: AttributeContext,\n        v: number,\n        oldMin: number,\n        oldMax: number,\n        newMin: number,\n        newMax: number,\n    ) => {\n        return Math.round(\n            ((v - oldMin) / (oldMax - oldMin)) * (newMax - newMin) + newMin,\n        );\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: fluent:missing-metadata-24-filled\n// Slug: Add headers to fetch requests\n// Description: This plugin allows you to add headers to fetch requests.  Once you add this attribute the headers will be added to the fetch request.\n\nimport { AttributePlugin } from \"../../../../engine\";\n\nexport const Header: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"header\",\n    mustHaveEmptyKey: true,\n    mustNotEmptyExpression: true,\n\n    onLoad: (ctx) => {\n        ctx.upsertIfMissingFromStore(\"_dsPlugins.fetch.headers\", {});\n\n        const headers: Object = ctx.expressionFn(ctx);\n        for (const [key, value] of Object.entries(headers)) {\n            ctx.store()._dsPlugins.fetch.headers[key] = value;\n        }\n\n        return () => {\n            for (const key of Object.keys(headers)) {\n                delete ctx.store()._dsPlugins.fetch.headers[key];\n            }\n        };\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: carbon:url\n// Slug: Replace the current URL with a new URL\n// Description: This plugin allows you to replace the current URL with a new URL.  Once you add this attribute the current URL will be replaced with the new URL.\n\nimport { AttributePlugin } from \"../../../../engine\";\n\nexport const ReplaceUrl: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"replaceUrl\",\n    mustHaveEmptyKey: true,\n    mustNotEmptyExpression: true,\n\n    onLoad: (ctx) => {\n        const value = ctx.expressionFn(ctx);\n        const baseUrl = window.location.href;\n        const url = new URL(value, baseUrl).toString();\n\n        window.history.replaceState({}, \"\", url);\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: akar-icons:link-chain\n// Slug: Bind attributes to expressions\n// Description: Any attribute can be bound to an expression. The attribute will be updated reactively whenever the expression signal changes.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { kebabize } from \"../../../../utils/text\";\n\nexport const Bind: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"bind\",\n    mustNotEmptyKey: true,\n    mustNotEmptyExpression: true,\n\n    onLoad: (ctx) => {\n        return ctx.reactivity.effect(async () => {\n            const key = kebabize(ctx.key);\n            const value = ctx.expressionFn(ctx);\n            let v: string;\n            if (typeof value === \"string\") {\n                v = value;\n            } else {\n                v = JSON.stringify(value);\n            }\n            if (!v || v === \"false\" || v === \"null\" || v === \"undefined\") {\n                ctx.el.removeAttribute(key);\n            } else {\n                ctx.el.setAttribute(key, v);\n            }\n        });\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: ic:baseline-format-paint\n// Slug: Add or remove classes from an element reactively\n// Description: This action adds or removes classes from an element reactively based on the expression provided. The expression should be an object where the keys are the class names and the values are booleans. If the value is true, the class is added. If the value is false, the class is removed.\n\nimport { AttributePlugin } from \"../../../../engine\";\n\nexport const Class: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"class\",\n    mustHaveEmptyKey: true,\n    mustNotEmptyExpression: true,\n\n    onLoad: (ctx) => {\n        const classes: Object = ctx.expressionFn(ctx);\n\n        return ctx.reactivity.effect(() => {\n            for (const [k, v] of Object.entries(classes)) {\n                const clss = k.split(\" \");\n                if (v) {\n                    ctx.el.classList.add(...clss);\n                } else {\n                    ctx.el.classList.remove(...clss);\n                }\n            }\n        });\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: clarity:two-way-arrows-line\n// Slug: Enable two-way data binding\n// Description: This attribute plugin enables two-way data binding for input elements.\n\nimport { AttributePlugin, RegexpGroups } from \"../../../../engine\";\n\nconst dataURIRegex = /^data:(?<mime>[^;]+);base64,(?<contents>.*)$/;\nconst updateModelEvents = [\"change\", \"input\", \"keydown\"];\n\nexport const Model: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"model\",\n    mustHaveEmptyKey: true,\n    preprocessors: {\n        post: [\n            {\n                pluginType: \"preprocessor\",\n                name: \"model\",\n                regexp: /(?<whole>.+)/g,\n                replacer: (groups: RegexpGroups) => {\n                    const { whole } = groups;\n                    return `ctx.store().${whole}`;\n                },\n            },\n        ],\n    },\n    // bypassExpressionFunctionCreation: () => true,\n    onLoad: (ctx) => {\n        const { el, expression } = ctx;\n        const signal = ctx.expressionFn(ctx);\n        const tnl = el.tagName.toLowerCase();\n\n        if (expression.startsWith(\"ctx.store().ctx.store()\")) {\n            throw new Error(\n                `Model attribute on #${el.id} must have a signal name, you probably prefixed with $ by accident`,\n            );\n        }\n\n        const isInput = tnl.includes(\"input\");\n        const type = el.getAttribute(\"type\");\n        const isCheckbox = tnl.includes(\"checkbox\") ||\n            (isInput && type === \"checkbox\");\n        const isSelect = tnl.includes(\"select\");\n        const isRadio = tnl.includes(\"radio\") || (isInput && type === \"radio\");\n        const isFile = isInput && type === \"file\";\n\n        const signalName = expression.replaceAll(\"ctx.store().\", \"\");\n        if (isRadio) {\n            const name = el.getAttribute(\"name\");\n            if (!name?.length) {\n                el.setAttribute(\"name\", signalName);\n            }\n        }\n\n        const setInputFromSignal = () => {\n            if (!signal) {\n                throw new Error(\n                    `Signal '${signalName}' not found in a data-model attribute on #${el.id}`,\n                );\n            }\n            const hasValue = \"value\" in el;\n            const v = signal.value;\n            if (isCheckbox || isRadio) {\n                const input = el as HTMLInputElement;\n                if (isCheckbox) {\n                    input.checked = v;\n                } else if (isRadio) {\n                    // evaluate the value as string to handle any type casting\n                    // automatically since the attribute has to be a string anyways\n                    input.checked = `${v}` === input.value;\n                }\n            } else if (isFile) {\n                // File input reading from a signal is not supported yet\n            } else if (isSelect) {\n                const select = el as HTMLSelectElement;\n                if (select.multiple) {\n                    const v = signal.value;\n                    Array.from(select.options).forEach((opt) => {\n                        if (opt?.disabled) return;\n                        opt.selected = v.includes(opt.value);\n                    });\n                } else {\n                    select.value = `${v}`;\n                }\n            } else if (hasValue) {\n                el.value = `${v}`;\n            } else {\n                el.setAttribute(\"value\", `${v}`);\n            }\n        };\n        const cleanupSetInputFromSignal = ctx.reactivity.effect(\n            setInputFromSignal,\n        );\n\n        const setSignalFromInput = async () => {\n            if (isFile) {\n                const files = [...((el as HTMLInputElement)?.files || [])],\n                    allContents: string[] = [],\n                    allMimes: string[] = [],\n                    allNames: string[] = [];\n\n                await Promise.all(\n                    files.map((f) => {\n                        return new Promise<void>((resolve) => {\n                            const reader = new FileReader();\n                            reader.onload = () => {\n                                if (typeof reader.result !== \"string\") {\n                                    throw new Error(\n                                        `Invalid result type: ${typeof reader\n                                            .result}`,\n                                    );\n                                }\n                                const match = reader.result.match(dataURIRegex);\n                                if (!match?.groups) {\n                                    throw new Error(\n                                        `Invalid data URI: ${reader.result}`,\n                                    );\n                                }\n                                allContents.push(match.groups.contents);\n                                allMimes.push(match.groups.mime);\n                                allNames.push(f.name);\n                            };\n                            reader.onloadend = () => resolve(void 0);\n                            reader.readAsDataURL(f);\n                        });\n                    }),\n                );\n\n                signal.value = allContents;\n                const s = ctx.store();\n                const mimeName = `${signalName}Mimes`,\n                    nameName = `${signalName}Names`;\n                if (mimeName in s) {\n                    s[`${mimeName}`].value = allMimes;\n                }\n                if (nameName in s) {\n                    s[`${nameName}`].value = allNames;\n                }\n                return;\n            }\n\n            const current = signal.value;\n            const input = (el as HTMLInputElement) || (el as HTMLElement);\n\n            if (typeof current === \"number\") {\n                signal.value = Number(\n                    input.value || input.getAttribute(\"value\"),\n                );\n            } else if (typeof current === \"string\") {\n                signal.value = input.value || input.getAttribute(\"value\") || \"\";\n            } else if (typeof current === \"boolean\") {\n                if (isCheckbox) {\n                    signal.value = input.checked ||\n                        input.getAttribute(\"checked\") === \"true\";\n                } else {\n                    signal.value = Boolean(\n                        input.value || input.getAttribute(\"value\"),\n                    );\n                }\n            } else if (typeof current === \"undefined\") {\n            } else if (typeof current === \"bigint\") {\n                signal.value = BigInt(\n                    input.value || input.getAttribute(\"value\") || \"0\",\n                );\n            } else if (Array.isArray(current)) {\n                // check if the input is a select element\n                if (isSelect) {\n                    const select = el as HTMLSelectElement;\n                    const selectedOptions = [...select.selectedOptions];\n                    const selectedValues = selectedOptions.map((opt) =>\n                        opt.value\n                    );\n                    signal.value = selectedValues;\n                } else {\n                    signal.value = JSON.parse(input.value).split(\",\");\n                }\n                console.log(input.value);\n            } else {\n                console.log(typeof current);\n                throw new Error(\n                    `Unsupported type ${typeof current} for signal ${signalName}`,\n                );\n            }\n        };\n\n        const parts = el.tagName.split(\"-\");\n        const isCustomElement = parts.length > 1;\n        if (isCustomElement) {\n            const customElementPrefix = parts[0].toLowerCase();\n            updateModelEvents.forEach((eventType) => {\n                updateModelEvents.push(`${customElementPrefix}-${eventType}`);\n            });\n        }\n\n        updateModelEvents.forEach((eventType) =>\n            el.addEventListener(eventType, setSignalFromInput)\n        );\n\n        return () => {\n            cleanupSetInputFromSignal();\n            updateModelEvents.forEach((event) =>\n                el.removeEventListener(event, setSignalFromInput)\n            );\n        };\n    },\n};\n", "export function argsToMs(args: string[] | undefined) {\n    if (!args || args?.length === 0) return 0;\n\n    for (const arg of args) {\n        if (arg.endsWith(\"ms\")) {\n            return Number(arg.replace(\"ms\", \"\"));\n        } else if (arg.endsWith(\"s\")) {\n            return Number(arg.replace(\"s\", \"\")) * 1000;\n        }\n\n        try {\n            return parseFloat(arg);\n        } catch (e) {}\n    }\n\n    return 0;\n}\n\nexport function argsHas(\n    args: string[] | undefined,\n    arg: string,\n    defaultValue = false,\n) {\n    if (!args) return false;\n    return args.includes(arg) || defaultValue;\n}\n", "export type TimerHandler = (...args: any[]) => void;\n\nexport function debounce(\n    callback: TimerHandler,\n    wait: number,\n    leading = false,\n    trailing = true,\n): TimerHandler {\n    let timer = -1;\n\n    const resetTimer = () => timer && clearTimeout(timer);\n\n    return function wrapper(...args: any[]) {\n        resetTimer();\n\n        if (leading && !timer) {\n            callback(...args);\n        }\n\n        timer = setTimeout(() => {\n            if (trailing) {\n                callback(...args);\n            }\n            resetTimer();\n        }, wait);\n    };\n}\n\nexport function throttle(\n    callback: TimerHandler,\n    wait: number,\n    leading = true,\n    trailing = false,\n): TimerHandler {\n    let waiting = false;\n\n    return function wrapper(...args: any[]) {\n        if (waiting) return;\n\n        if (leading) {\n            callback(...args);\n        }\n\n        waiting = true;\n        setTimeout(() => {\n            waiting = false;\n            if (trailing) {\n                callback(...args);\n            }\n        }, wait);\n    };\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:mail\n// Slug: Add an event listener to an element\n// Description: This action adds an event listener to an element. The event listener can be triggered by a variety of events, such as clicks, keypresses, and more. The event listener can also be set to trigger only once, or to be passive or capture. The event listener can also be debounced or throttled. The event listener can also be set to trigger only when the event target is outside the element.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { argsHas, argsToMs } from \"../../../../utils/arguments\";\nimport { remoteSignals } from \"../../../../utils/signals\";\nimport { kebabize } from \"../../../../utils/text\";\nimport { debounce, throttle } from \"../../../../utils/timing\";\n\nconst knownOnModifiers = new Set([\n    \"window\",\n    \"once\",\n    \"passive\",\n    \"capture\",\n    \"debounce\",\n    \"throttle\",\n    \"remote\",\n    \"outside\",\n]);\n\nlet lastStoreMarshalled = \"\";\n\n// Sets the event listener of the element\nexport const On: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"on\",\n    mustNotEmptyKey: true,\n    mustNotEmptyExpression: true,\n    argumentNames: [\"evt\"],\n    onLoad: (ctx) => {\n        const { el, key, expressionFn } = ctx;\n\n        let target: Element | Window | Document = ctx.el;\n        if (ctx.modifiers.get(\"window\")) {\n            target = window;\n        }\n\n        let callback = (evt?: Event) => {\n            ctx.sendDatastarEvent(\"plugin\", \"event\", key, target, \"triggered\");\n            expressionFn(ctx, evt);\n        };\n\n        const debounceArgs = ctx.modifiers.get(\"debounce\");\n        if (debounceArgs) {\n            const wait = argsToMs(debounceArgs);\n            const leading = argsHas(debounceArgs, \"leading\", false);\n            const trailing = argsHas(debounceArgs, \"noTrail\", true);\n            callback = debounce(callback, wait, leading, trailing);\n        }\n\n        const throttleArgs = ctx.modifiers.get(\"throttle\");\n        if (throttleArgs) {\n            const wait = argsToMs(throttleArgs);\n            const leading = argsHas(throttleArgs, \"noLead\", true);\n            const trailing = argsHas(throttleArgs, \"noTrail\", false);\n            callback = throttle(callback, wait, leading, trailing);\n        }\n\n        const evtListOpts: AddEventListenerOptions = {\n            capture: true,\n            passive: false,\n            once: false,\n        };\n        if (!ctx.modifiers.has(\"capture\")) evtListOpts.capture = false;\n        if (ctx.modifiers.has(\"passive\")) evtListOpts.passive = true;\n        if (ctx.modifiers.has(\"once\")) evtListOpts.once = true;\n\n        const unknownModifierKeys = [...ctx.modifiers.keys()].filter((key) =>\n            !knownOnModifiers.has(key)\n        );\n\n        unknownModifierKeys.forEach((attrName) => {\n            const eventValues = ctx.modifiers.get(attrName) || [];\n            const cb = callback;\n            const revisedCallback = () => {\n                const evt = event as any;\n                const attr = evt[attrName];\n                let valid: boolean;\n\n                if (typeof attr === \"function\") {\n                    valid = attr(...eventValues);\n                } else if (typeof attr === \"boolean\") {\n                    valid = attr;\n                } else if (typeof attr === \"string\") {\n                    const lowerAttr = attr.toLowerCase().trim();\n                    const expr = eventValues.join(\"\").toLowerCase().trim();\n                    valid = lowerAttr === expr;\n                } else {\n                    const msg =\n                        `Invalid value for ${attrName} modifier on ${key} on ${el}`;\n                    console.error(msg);\n                    debugger;\n                    throw new Error(msg);\n                }\n\n                if (valid) {\n                    cb(evt);\n                }\n            };\n            callback = revisedCallback;\n        });\n\n        const eventName = kebabize(key).toLowerCase();\n        switch (eventName) {\n            case \"load\":\n                callback();\n                delete ctx.el.dataset.onLoad;\n                return () => {};\n\n            case \"raf\":\n                let rafId: number | undefined;\n                const raf = () => {\n                    callback();\n                    rafId = requestAnimationFrame(raf);\n                };\n                rafId = requestAnimationFrame(raf);\n\n                return () => {\n                    if (rafId) cancelAnimationFrame(rafId);\n                };\n\n            case \"store-change\":\n                return ctx.reactivity.effect(() => {\n                    const store = ctx.store();\n                    let storeValue = store.value;\n                    if (ctx.modifiers.has(\"remote\")) {\n                        storeValue = remoteSignals(storeValue);\n                    }\n                    const current = JSON.stringify(storeValue);\n                    if (lastStoreMarshalled !== current) {\n                        lastStoreMarshalled = current;\n                        callback();\n                    }\n                });\n\n            default:\n                const testOutside = ctx.modifiers.has(\"outside\");\n                if (testOutside) {\n                    target = document;\n                    const cb = callback;\n                    let called = false;\n                    const targetOutsideCallback = (e?: Event) => {\n                        const targetHTML = e?.target as HTMLElement;\n                        if (!targetHTML) return;\n                        const isEl = el.id === targetHTML.id;\n                        if (isEl && called) {\n                            called = false;\n                        }\n                        if (!isEl && !called) {\n                            cb(e);\n                            called = true;\n                        }\n                    };\n                    callback = targetOutsideCallback;\n                }\n\n                target.addEventListener(eventName, callback, evtListOpts);\n                return () => {\n                    // console.log(`Removing event listener for ${eventName} on ${el}`)\n                    target.removeEventListener(eventName, callback);\n                };\n        }\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: mdi:cursor-pointer\n// Slug: Create a reference to an element\n// Description: This attribute creates a reference to an element that can be used in other expressions.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { elemToSelector } from \"../../../../utils/dom\";\n\n// Sets the value of the element\nexport const RefAttribute: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"ref\",\n    mustHaveEmptyKey: true,\n    mustNotEmptyExpression: true,\n    bypassExpressionFunctionCreation: () => true,\n    onLoad: (ctx) => {\n        ctx.upsertIfMissingFromStore(\"_dsPlugins.refs\", {});\n        const { el, expression } = ctx;\n        const s = ctx.store();\n\n        const revised = {\n            _dsPlugins: {\n                refs: {\n                    ...s._dsPlugins.refs.value,\n                    [expression]: elemToSelector(el),\n                },\n            },\n        };\n        ctx.mergeStore(revised);\n\n        return () => {\n            const s = ctx.store();\n            const revised = { ...s._dsPlugins.refs.value };\n            delete revised[expression];\n            s._dsPlugins.refs = revised;\n        };\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: tabler:typography\n// Slug: Set the text content of an element\n// Description: This attribute sets the text content of an element to the result of the expression.\n\nimport { AttributePlugin } from \"../../../../engine\";\n\nexport const Text: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"text\",\n    mustHaveEmptyKey: true,\n\n    onLoad: (ctx) => {\n        const { el, expressionFn } = ctx;\n        if (!(el instanceof HTMLElement)) {\n            throw new Error(\"Element is not HTMLElement\");\n        }\n        return ctx.reactivity.effect(() => {\n            const res = expressionFn(ctx);\n            el.textContent = `${res}`;\n        });\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: mdi:floppy-variant\n// Slug: Persist data to local storage or session storage\n// Description: This plugin allows you to persist data to local storage or session storage.  Once you add this attribute the data will be persisted to local storage or session storage.\n\nimport {\n    AttributePlugin,\n    DATASTAR,\n    DATASTAR_EVENT,\n    DatastarEvent,\n} from \"../../../../engine\";\nimport { remoteSignals } from \"../../../../utils/signals\";\n\nexport const Persist: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"persist\",\n    allowedModifiers: new Set([\"local\", \"session\", \"remote\"]),\n\n    onLoad: (ctx) => {\n        const key = ctx.key || DATASTAR;\n        const expression = ctx.expression;\n        const keys = new Set<string>();\n\n        if (expression.trim() !== \"\") {\n            const value = ctx.expressionFn(ctx);\n            const parts = value.split(\" \");\n            for (const part of parts) {\n                keys.add(part);\n            }\n        }\n\n        let lastMarshalled = \"\";\n        const storageType = ctx.modifiers.has(\"session\") ? \"session\" : \"local\";\n        const useRemote = ctx.modifiers.has(\"remote\");\n\n        const storeUpdateHandler = ((_: CustomEvent<DatastarEvent>) => {\n            let store = ctx.store();\n            if (useRemote) {\n                store = remoteSignals(store);\n            }\n            if (keys.size > 0) {\n                const newStore: Record<string, any> = {};\n                for (const key of keys) {\n                    const parts = key.split(\".\");\n                    let newSubstore = newStore;\n                    let subStore = store;\n                    for (let i = 0; i < parts.length - 1; i++) {\n                        const part = parts[i];\n                        if (!newSubstore[part]) {\n                            newSubstore[part] = {};\n                        }\n                        newSubstore = newSubstore[part];\n                        subStore = subStore[part];\n                    }\n\n                    const lastPart = parts[parts.length - 1];\n                    newSubstore[lastPart] = subStore[lastPart];\n                }\n                store = newStore;\n            }\n\n            const marshalledStore = JSON.stringify(store);\n\n            if (marshalledStore === lastMarshalled) {\n                return;\n            }\n\n            if (storageType === \"session\") {\n                window.sessionStorage.setItem(key, marshalledStore);\n            } else {\n                window.localStorage.setItem(key, marshalledStore);\n            }\n\n            lastMarshalled = marshalledStore;\n        }) as EventListener;\n\n        window.addEventListener(DATASTAR_EVENT, storeUpdateHandler);\n\n        let marshalledStore: string | null;\n\n        if (storageType === \"session\") {\n            marshalledStore = window.sessionStorage.getItem(key);\n        } else {\n            marshalledStore = window.localStorage.getItem(key);\n        }\n\n        if (!!marshalledStore) {\n            const store = JSON.parse(marshalledStore);\n            for (const key in store) {\n                const value = store[key];\n                ctx.upsertIfMissingFromStore(key, value);\n            }\n        }\n\n        return () => {\n            window.removeEventListener(DATASTAR_EVENT, storeUpdateHandler);\n        };\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: mdi-light:vector-intersection\n// Slug: Run expression when element intersects with viewport\n// Description: An attribute that runs an expression when the element intersects with the viewport.\n\nimport { AttributePlugin } from \"../../../../engine\";\n\nconst ONCE = \"once\";\nconst HALF = \"half\";\nconst FULL = \"full\";\n\n// Run expression when element intersects with viewport\nexport const Intersection: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"intersects\",\n    allowedModifiers: new Set([ONCE, HALF, FULL]),\n    mustHaveEmptyKey: true,\n    onLoad: (ctx) => {\n        const { modifiers } = ctx;\n        const options = { threshold: 0 };\n        if (modifiers.has(FULL)) options.threshold = 1;\n        else if (modifiers.has(HALF)) options.threshold = 0.5;\n\n        const observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    ctx.expressionFn(ctx);\n                    if (modifiers.has(ONCE)) {\n                        observer.disconnect();\n                        delete ctx.el.dataset[ctx.rawKey];\n                    }\n                }\n            });\n        }, options);\n\n        observer.observe(ctx.el);\n        return () => observer.disconnect();\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: hugeicons:mouse-scroll-01\n// Slug: Scroll an element into view\n// Description: This attribute scrolls the element into view.\n\nimport { AttributeContext, AttributePlugin } from \"../../../../engine\";\nimport { scrollIntoView } from \"../../../../utils/dom\";\n\n// Scrolls the element into view\nexport const ScrollIntoView: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"scrollIntoView\",\n    mustHaveEmptyKey: true,\n    mustHaveEmptyExpression: true,\n    allowedModifiers: new Set([\n        \"smooth\",\n        \"instant\",\n        \"auto\",\n        \"hstart\",\n        \"hcenter\",\n        \"hend\",\n        \"hnearest\",\n        \"vstart\",\n        \"vcenter\",\n        \"vend\",\n        \"vnearest\",\n        \"focus\",\n    ]),\n\n    onLoad: ({ el, modifiers, rawKey }: AttributeContext) => {\n        if (!el.tabIndex) el.setAttribute(\"tabindex\", \"0\");\n        const opts: ScrollIntoViewOptions = {\n            behavior: \"smooth\",\n            block: \"center\",\n            inline: \"center\",\n        };\n        if (modifiers.has(\"smooth\")) opts.behavior = \"smooth\";\n        if (modifiers.has(\"instant\")) opts.behavior = \"instant\";\n        if (modifiers.has(\"auto\")) opts.behavior = \"auto\";\n        if (modifiers.has(\"hstart\")) opts.inline = \"start\";\n        if (modifiers.has(\"hcenter\")) opts.inline = \"center\";\n        if (modifiers.has(\"hend\")) opts.inline = \"end\";\n        if (modifiers.has(\"hnearest\")) opts.inline = \"nearest\";\n        if (modifiers.has(\"vstart\")) opts.block = \"start\";\n        if (modifiers.has(\"vcenter\")) opts.block = \"center\";\n        if (modifiers.has(\"vend\")) opts.block = \"end\";\n        if (modifiers.has(\"vnearest\")) opts.block = \"nearest\";\n\n        scrollIntoView(el, opts, modifiers.has(\"focus\"));\n        delete el.dataset[rawKey];\n        return () => {};\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: streamline:interface-edit-view-eye-eyeball-open-view\n// Slug: Show or hide an element\n// Description: This attribute shows or hides an element based on the value of the expression. If the expression is true, the element is shown. If the expression is false, the element is hidden. The element is hidden by setting the display property to none. If the duration modifier is provided, the element is shown or hidden with a fade effect. The duration modifier specifies the duration of the fade effect in milliseconds. The important modifier can be used to set the priority of the style property.\n\nimport { AttributePlugin, DATASTAR } from \"../../../../engine\";\nimport { argsToMs } from \"../../../../utils/arguments\";\n\nconst DISPLAY = \"display\";\nconst NONE = \"none\";\nconst IMPORTANT = \"important\";\nconst DURATION = \"duration\";\n\nconst SHOW_CLASS = `${DATASTAR}-showing`;\nconst HIDE_CLASS = `${DATASTAR}-hiding`;\nconst SHOW_DURATION_TRANSITION_STYLE = `${DATASTAR}-show-duration-transition`;\n\nexport const Show: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"show\",\n    \"allowedModifiers\": new Set([IMPORTANT, DURATION]),\n\n    onLoad: (ctx) => {\n        const { el, modifiers, expressionFn, reactivity } = ctx;\n\n        const isImportant = modifiers.has(IMPORTANT);\n        const priority = isImportant ? IMPORTANT : undefined;\n\n        let showFn, hideFn;\n\n        const durationArgs = ctx.modifiers.get(DURATION);\n        if (durationArgs) {\n            let style = document.getElementById(SHOW_DURATION_TRANSITION_STYLE);\n            if (!style) {\n                style = document.createElement(\"style\");\n                style.id = SHOW_DURATION_TRANSITION_STYLE;\n                document.head.appendChild(style);\n                const durationMs = argsToMs(durationArgs) || \"300\";\n                style.innerHTML = `\n            .${SHOW_CLASS} {\n              visibility: visible;\n              transition: opacity ${durationMs}ms linear;\n            }\n            .${HIDE_CLASS} {\n              visibility: hidden;\n              transition: visibility 0s ${durationMs}ms, opacity ${durationMs}ms linear;\n            }\n          `;\n            }\n\n            const transitionEndHandler =\n                (classNameToRemove: string) => (event: Event) => {\n                    if (event.target === el) {\n                        el.classList.remove(classNameToRemove);\n                        el.removeEventListener(\n                            \"transitionend\",\n                            transitionEndHandler(classNameToRemove),\n                        );\n                    }\n                };\n\n            showFn = () => {\n                el.addEventListener(\n                    \"transitionend\",\n                    transitionEndHandler(SHOW_CLASS),\n                );\n                el.classList.add(SHOW_CLASS);\n                requestAnimationFrame(() => {\n                    el.style.setProperty(\"opacity\", \"1\", priority);\n                });\n            };\n\n            hideFn = () => {\n                el.addEventListener(\n                    \"transitionend\",\n                    transitionEndHandler(HIDE_CLASS),\n                );\n                el.classList.add(HIDE_CLASS);\n                requestAnimationFrame(() => {\n                    el.style.setProperty(\"opacity\", \"0\", priority);\n                });\n            };\n        } else {\n            showFn = () => {\n                if (el.style.length === 1 && el.style.display === NONE) {\n                    el.style.removeProperty(DISPLAY);\n                } else {\n                    el.style.setProperty(DISPLAY, \"\", priority);\n                }\n            };\n\n            hideFn = () => {\n                el.style.setProperty(DISPLAY, NONE, priority);\n            };\n        }\n\n        return reactivity.effect(async () => {\n            const expressionEvaluated = await expressionFn(ctx);\n            const shouldShow = !!expressionEvaluated;\n\n            if (shouldShow) {\n                showFn();\n            } else {\n                hideFn();\n            }\n        });\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: game-icons:teleport\n// Slug: Teleport an element to another element\n// Description: This attribute teleports an element to another element in the DOM.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { nodeHTMLorSVGElement } from \"../../../../utils/dom\";\n\nconst PREPEND = \"prepend\";\nconst APPEND = \"append\";\nconst teleportParentErr = new Error(\n    \"Target element must have a parent if using prepend or append\",\n);\n// Teleports the element to another element\nexport const Teleport: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"teleport\",\n    allowedModifiers: new Set([PREPEND, APPEND]),\n    allowedTagRegexps: new Set([\"template\"]),\n    bypassExpressionFunctionCreation: () => true,\n    onLoad: (ctx) => {\n        const { el, modifiers, expression } = ctx;\n        if (!(el instanceof HTMLTemplateElement)) {\n            throw new Error(`el must be a template element`);\n        }\n\n        const target = document.querySelector(expression);\n        if (!target) {\n            throw new Error(`Target element not found: ${expression}`);\n        }\n\n        if (!el.content) {\n            throw new Error(\"Template element must have content\");\n        }\n\n        const n = el.content.cloneNode(true);\n        const nEl = nodeHTMLorSVGElement(n as Element);\n        if (nEl?.firstElementChild) {\n            throw new Error(\"Empty template\");\n        }\n\n        if (modifiers.has(PREPEND)) {\n            if (!target.parentNode) throw teleportParentErr;\n            target.parentNode.insertBefore(n, target);\n        } else if (modifiers.has(APPEND)) {\n            if (!target.parentNode) throw teleportParentErr;\n            target.parentNode.insertBefore(n, target.nextSibling);\n        } else {\n            target.appendChild(n);\n        }\n    },\n};\n", "export interface DocumentSupportingViewTransitionAPI {\n    startViewTransition(\n        updateCallback: () => Promise<void> | void,\n    ): ViewTransition;\n}\n\nexport interface ViewTransition {\n    finished: Promise<void>;\n    ready: Promise<void>;\n    updateCallbackDone: Promise<void>;\n    skipTransition(): void;\n}\n\nexport const docWithViewTransitionAPI =\n    document as unknown as DocumentSupportingViewTransitionAPI;\nexport const supportsViewTransitions = !!docWithViewTransitionAPI\n    .startViewTransition;\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:masked-transitions\n// Slug: Setup view transitions\n// Description: This attribute plugin sets up view transitions for the current view. This plugin requires the view transition API to be enabled in the browser. If the browser does not support view transitions, an error will be logged to the console.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { supportsViewTransitions } from \"../../../../utils/view-transitions\";\n\nexport const ViewTransition: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"viewTransition\",\n    onGlobalInit() {\n        let hasViewTransitionMeta = false;\n        document.head.childNodes.forEach((node) => {\n            if (\n                node instanceof HTMLMetaElement &&\n                node.name === \"view-transition\"\n            ) {\n                hasViewTransitionMeta = true;\n            }\n        });\n\n        if (!hasViewTransitionMeta) {\n            const meta = document.createElement(\"meta\");\n            meta.name = \"view-transition\";\n            meta.content = \"same-origin\";\n            document.head.appendChild(meta);\n        }\n    },\n    onLoad: (ctx) => {\n        if (!supportsViewTransitions) {\n            console.error(\"Browser does not support view transitions\");\n            return;\n        }\n\n        return ctx.reactivity.effect(() => {\n            const { el, expressionFn } = ctx;\n            let name = expressionFn(ctx);\n            if (!name) return;\n\n            const elVTASTyle = el.style as unknown as CSSStyleDeclaration;\n            elVTASTyle.viewTransitionName = name;\n        });\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:mail\n// Slug: Dispatch a custom event to a specified elements from the backend\n// Description: Dispatch a custom event to a specified elements from the backend\n\nimport { WatcherPlugin } from \"../../../../engine\";\nimport { datastarSSEEventWatcher } from \"./sseShared\";\n\nconst name = \"dispatchCustomEvent\";\nexport const DispatchCustomEvent: WatcherPlugin = {\n    pluginType: \"effect\",\n    name,\n    onGlobalInit: async (ctx) => {\n        datastarSSEEventWatcher(\n            ctx,\n            name,\n            ({\n                eventName,\n                selector = \"document\",\n                bubbles: bubblesRaw = \"true\",\n                cancelable: cancelableRaw = \"true\",\n                composed: composedRaw = \"true\",\n                detailJson = \"{}\",\n            }) => {\n                if (!eventName.length) {\n                    throw new Error(\n                        \"No event name provided for dispatch-custom-event\",\n                    );\n                }\n                const elements = selector === \"document\"\n                    ? [document]\n                    : document.querySelectorAll(selector);\n\n                const composed = composedRaw.trim() === \"true\";\n                const bubbles = bubblesRaw.trim() === \"true\";\n                const cancelable = cancelableRaw.trim() === \"true\";\n                const detail = JSON.parse(detailJson);\n\n                const event = new CustomEvent(eventName, {\n                    bubbles,\n                    cancelable,\n                    composed,\n                    detail,\n                });\n\n                elements.forEach((element) => {\n                    element.dispatchEvent(event);\n                });\n            },\n        );\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: tabler:file-type-js\n// Slug: Execute JavaScript from a Server-Sent Event\n// Description: Execute JavaScript from a Server-Sent Event\n\nimport { WatcherPlugin } from \"../../../../engine\";\nimport { datastarSSEEventWatcher } from \"./sseShared\";\n\nconst name = \"executeJs\";\nexport const ExecuteJS: WatcherPlugin = {\n    pluginType: \"effect\",\n    name,\n    onGlobalInit: async (ctx) => {\n        datastarSSEEventWatcher(\n            ctx,\n            name,\n            ({ autoRemoveScript: autoRemoveScriptRaw = \"true\", script }) => {\n                const autoRemoveScript = autoRemoveScriptRaw.trim() === \"true\";\n                if (!script?.length) {\n                    throw new Error(\"No script provided\");\n                }\n\n                const scriptEl = document.createElement(\"script\");\n                scriptEl.text = script;\n                document.head.appendChild(scriptEl);\n                if (autoRemoveScript) {\n                    scriptEl.remove();\n                }\n            },\n        );\n    },\n};\n", "const generatedByIdiomorphId = new WeakSet();\n\n//=============================================================================\n// Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n//=============================================================================\nexport function idiomorph(\n    oldNode: Document | Element,\n    newContent: string | Element,\n    config = {},\n) {\n    if (oldNode instanceof Document) {\n        oldNode = oldNode.documentElement;\n    }\n\n    let parsedContent: Element;\n    if (typeof newContent === \"string\") {\n        parsedContent = parseContent(newContent) as Element;\n    } else {\n        parsedContent = newContent;\n    }\n\n    const normalizedContent = normalizeContent(parsedContent);\n    const ctx = createMorphContext(oldNode, normalizedContent, config);\n\n    return morphNormalizedContent(oldNode, normalizedContent, ctx);\n}\n\nfunction morphNormalizedContent(\n    oldNode: Element,\n    normalizedNewContent: Element,\n    ctx: any,\n) {\n    if (ctx.head.block) {\n        const oldHead = oldNode.querySelector(\"head\");\n        const newHead = normalizedNewContent.querySelector(\"head\");\n        if (oldHead && newHead) {\n            const promises = handleHeadElement(newHead, oldHead, ctx);\n            // when head promises resolve, call morph again, ignoring the head tag\n            Promise.all(promises).then(() => {\n                morphNormalizedContent(\n                    oldNode,\n                    normalizedNewContent,\n                    Object.assign(ctx, {\n                        head: {\n                            block: false,\n                            ignore: true,\n                        },\n                    }),\n                );\n            });\n            return;\n        }\n    }\n\n    if (ctx.morphStyle === \"innerHTML\") {\n        // innerHTML, so we are only updating the children\n        morphChildren(normalizedNewContent, oldNode, ctx);\n        return oldNode.children;\n    } else if (ctx.morphStyle === \"outerHTML\" || ctx.morphStyle == null) {\n        // otherwise find the best element match in the new content, morph that, and merge its siblings\n        // into either side of the best match\n        const bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n        if (!bestMatch) {\n            throw new Error(\"Could not find best match\");\n        }\n\n        // stash the siblings that will need to be inserted on either side of the best match\n        const previousSibling = bestMatch?.previousSibling as Element;\n        const nextSibling = bestMatch?.nextSibling as Element;\n\n        // morph it\n        const morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);\n\n        if (bestMatch) {\n            // if there was a best match, merge the siblings in too and return the\n            // whole bunch\n            return insertSiblings(previousSibling, morphedNode, nextSibling);\n        } else {\n            // otherwise nothing was added to the DOM\n            return [];\n        }\n    } else {\n        throw \"Do not understand how to morph style \" + ctx.morphStyle;\n    }\n}\n\n/**\n * @param oldNode root node to merge content into\n * @param newContent new content to merge\n * @param ctx the merge context\n * @returns {Element} the element that ended up in the DOM\n */\nfunction morphOldNodeTo(oldNode: Element, newContent: Element, ctx: any) {\n    if (ctx.ignoreActive && oldNode === document.activeElement) {\n        // don't morph focused element\n    } else if (newContent == null) {\n        if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return;\n\n        oldNode.remove();\n        ctx.callbacks.afterNodeRemoved(oldNode);\n        return;\n    } else if (!isSoftMatch(oldNode, newContent)) {\n        if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return;\n        if (ctx.callbacks.beforeNodeAdded(newContent) === false) return;\n\n        if (!oldNode.parentElement) {\n            throw new Error(\"oldNode has no parentElement\");\n        }\n        oldNode.parentElement.replaceChild(newContent, oldNode);\n        ctx.callbacks.afterNodeAdded(newContent);\n        ctx.callbacks.afterNodeRemoved(oldNode);\n        return newContent;\n    } else {\n        if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) {\n            return;\n        }\n\n        if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n            // ignore the head element\n        } else if (\n            newContent instanceof HTMLHeadElement &&\n            oldNode instanceof HTMLHeadElement &&\n            ctx.head.style !== \"morph\"\n        ) {\n            handleHeadElement(newContent, oldNode, ctx);\n        } else {\n            syncNodeFrom(newContent, oldNode);\n            morphChildren(newContent, oldNode, ctx);\n        }\n        ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n        return oldNode;\n    }\n}\n\n/**\n * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n * by using id sets, we are able to better match up with content deeper in the DOM.\n *\n * Basic algorithm is, for each node in the new content:\n *\n * - if we have reached the end of the old parent, append the new content\n * - if the new content has an id set match with the current insertion point, morph\n * - search for an id set match\n * - if id set match found, morph\n * - otherwise search for a \"soft\" match\n * - if a soft match is found, morph\n * - otherwise, prepend the new node before the current insertion point\n *\n * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n *\n * @param {Element} newParent the parent element of the new content\n * @param {Element } oldParent the old content that we are merging the new content into\n * @param ctx the merge context\n */\nfunction morphChildren(newParent: Element, oldParent: Element, ctx: any) {\n    let nextNewChild = newParent.firstChild as Element | null;\n    let insertionPoint = oldParent.firstChild as Element | null;\n    let newChild;\n\n    // run through all the new content\n    while (nextNewChild) {\n        newChild = nextNewChild;\n        nextNewChild = newChild.nextSibling as Element | null;\n\n        // if we are at the end of the exiting parent's children, just append\n        if (insertionPoint == null) {\n            if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n            oldParent.appendChild(newChild);\n            ctx.callbacks.afterNodeAdded(newChild);\n            removeIdsFromConsideration(ctx, newChild);\n            continue;\n        }\n\n        // if the current node has an id set match then morph\n        if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n            morphOldNodeTo(insertionPoint, newChild, ctx);\n            insertionPoint = insertionPoint.nextSibling as Element | null;\n            removeIdsFromConsideration(ctx, newChild);\n            continue;\n        }\n\n        // otherwise search forward in the existing old children for an id set match\n        let idSetMatch = findIdSetMatch(\n            newParent,\n            oldParent,\n            newChild,\n            insertionPoint,\n            ctx,\n        );\n\n        // if we found a potential match, remove the nodes until that point and morph\n        if (idSetMatch) {\n            insertionPoint = removeNodesBetween(\n                insertionPoint,\n                idSetMatch,\n                ctx,\n            );\n            morphOldNodeTo(idSetMatch, newChild, ctx);\n            removeIdsFromConsideration(ctx, newChild);\n            continue;\n        }\n\n        // no id set match found, so scan forward for a soft match for the current node\n        let softMatch = findSoftMatch(newParent, newChild, insertionPoint, ctx);\n\n        // if we found a soft match for the current node, morph\n        if (softMatch) {\n            insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n            morphOldNodeTo(softMatch, newChild, ctx);\n            removeIdsFromConsideration(ctx, newChild);\n            continue;\n        }\n\n        // abandon all hope of morphing, just insert the new child before the insertion point\n        // and move on\n        if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n        oldParent.insertBefore(newChild, insertionPoint);\n        ctx.callbacks.afterNodeAdded(newChild);\n        removeIdsFromConsideration(ctx, newChild);\n    }\n\n    // remove any remaining old nodes that didn't match up with new content\n    while (insertionPoint !== null) {\n        let tempNode = insertionPoint;\n        insertionPoint = insertionPoint.nextSibling as Element | null;\n        removeNode(tempNode, ctx);\n    }\n}\n\n//=============================================================================\n// Attribute Syncing Code\n//=============================================================================\n\n/**\n * syncs a given node with another node, copying over all attributes and\n * inner element state from the 'from' node to the 'to' node\n *\n * @param {Element} from the element to copy attributes & state from\n * @param {Element} to the element to copy attributes & state to\n */\nfunction syncNodeFrom(from: Element, to: Element) {\n    let type = from.nodeType;\n\n    // if is an element type, sync the attributes from the\n    // new node into the new node\n    if (type === 1 /* element type */) {\n        for (const fromAttribute of from.attributes) {\n            const toAttribute = to.getAttribute(fromAttribute.name);\n            if (toAttribute !== fromAttribute.value) {\n                to.setAttribute(fromAttribute.name, fromAttribute.value);\n            }\n        }\n        for (const toAttribute of to.attributes) {\n            if (!from.hasAttribute(toAttribute.name)) {\n                to.removeAttribute(toAttribute.name);\n            }\n        }\n    }\n\n    // sync text nodes\n    if (type === Node.COMMENT_NODE || type === Node.TEXT_NODE) {\n        if (to.nodeValue !== from.nodeValue) {\n            to.nodeValue = from.nodeValue;\n        }\n    }\n\n    // NB: many bothans died to bring us information:\n    //\n    // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n    // https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n\n    // sync input value\n    if (\n        from instanceof HTMLInputElement && to instanceof HTMLInputElement &&\n        from.type !== \"file\"\n    ) {\n        to.value = from.value || \"\";\n        syncAttribute(from, to, \"value\");\n\n        // sync boolean attributes\n        syncAttribute(from, to, \"checked\");\n        syncAttribute(from, to, \"disabled\");\n    } else if (from instanceof HTMLOptionElement) {\n        syncAttribute(from, to, \"selected\");\n    } else if (\n        from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement\n    ) {\n        const fromValue = from.value;\n        const toValue = to.value;\n        if (fromValue !== toValue) {\n            to.value = fromValue;\n        }\n        if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n            to.firstChild.nodeValue = fromValue;\n        }\n    }\n}\n\nfunction syncAttribute(from: Element, to: Element, attributeName: string) {\n    const fAttr = from.getAttribute(attributeName);\n    const tAttr = to.getAttribute(attributeName);\n\n    if (fAttr !== tAttr) {\n        if (fAttr) {\n            to.setAttribute(attributeName, fAttr);\n        } else {\n            to.removeAttribute(attributeName);\n        }\n    }\n}\n\n//=============================================================================\n// the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n//=============================================================================\nfunction handleHeadElement(\n    newHeadTag: HTMLHeadElement,\n    currentHead: HTMLHeadElement,\n    ctx: any,\n) {\n    const added = [];\n    const removed = [];\n    const preserved = [];\n    const nodesToAppend = [];\n\n    const headMergeStyle = ctx.head.style;\n\n    // put all new head elements into a Map, by their outerHTML\n    const srcToNewHeadNodes = new Map();\n    for (const newHeadChild of newHeadTag.children) {\n        srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n    }\n\n    // for each elt in the current head\n    for (const currentHeadElt of currentHead.children) {\n        // If the current head element is in the map\n        let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n        let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n        let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n        if (inNewContent || isPreserved) {\n            if (isReAppended) {\n                // remove the current version and let the new version replace it and re-execute\n                removed.push(currentHeadElt);\n            } else {\n                // this element already exists and should not be re-appended, so remove it from\n                // the new content map, preserving it in the DOM\n                srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n                preserved.push(currentHeadElt);\n            }\n        } else {\n            if (headMergeStyle === \"append\") {\n                // we are appending and this existing element is not new content\n                // so if and only if it is marked for re-append do we do anything\n                if (isReAppended) {\n                    removed.push(currentHeadElt);\n                    nodesToAppend.push(currentHeadElt);\n                }\n            } else {\n                // if this is a merge, we remove this content since it is not in the new head\n                if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n                    removed.push(currentHeadElt);\n                }\n            }\n        }\n    }\n\n    // Push the remaining new head elements in the Map into the\n    // nodes to append to the head tag\n    nodesToAppend.push(...srcToNewHeadNodes.values());\n    // console.log('to append: ', nodesToAppend)\n\n    const promises = [];\n    for (const newNode of nodesToAppend) {\n        // console.log('adding: ', newNode)\n        const newElt = document.createRange().createContextualFragment(\n            newNode.outerHTML,\n        ).firstChild as Element | null;\n        if (!newElt) {\n            throw new Error(\n                \"could not create new element from: \" + newNode.outerHTML,\n            );\n        }\n        // console.log(newElt)\n        if (!!ctx.callbacks.beforeNodeAdded(newElt)) {\n            if (newElt.hasAttribute(\"href\") || newElt.hasAttribute(\"src\")) {\n                let resolver: (value: unknown) => void;\n                const promise = new Promise((resolve) => {\n                    resolver = resolve;\n                });\n                newElt.addEventListener(\"load\", function () {\n                    resolver(undefined);\n                });\n                promises.push(promise);\n            }\n            currentHead.appendChild(newElt);\n            ctx.callbacks.afterNodeAdded(newElt);\n            added.push(newElt);\n        }\n    }\n\n    // remove all removed elements, after we have appended the new elements to avoid\n    // additional network requests for things like style sheets\n    for (const removedElement of removed) {\n        if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n            currentHead.removeChild(removedElement);\n            ctx.callbacks.afterNodeRemoved(removedElement);\n        }\n    }\n\n    ctx.head.afterHeadMorphed(currentHead, {\n        added: added,\n        kept: preserved,\n        removed: removed,\n    });\n    return promises;\n}\n\n//=============================================================================\n// Misc\n//=============================================================================\nfunction noOp() {}\n\nfunction createMorphContext(\n    oldNode: Element,\n    newContent: Element,\n    config: any,\n) {\n    return {\n        target: oldNode,\n        newContent: newContent,\n        config: config,\n        morphStyle: config.morphStyle,\n        ignoreActive: config.ignoreActive,\n        idMap: createIdMap(oldNode, newContent),\n        deadIds: new Set(),\n        callbacks: Object.assign(\n            {\n                beforeNodeAdded: noOp,\n                afterNodeAdded: noOp,\n                beforeNodeMorphed: noOp,\n                afterNodeMorphed: noOp,\n                beforeNodeRemoved: noOp,\n                afterNodeRemoved: noOp,\n            },\n            config.callbacks,\n        ),\n        head: Object.assign(\n            {\n                style: \"merge\",\n                shouldPreserve: (elt: Element) =>\n                    elt.getAttribute(\"im-preserve\") === \"true\",\n                shouldReAppend: (elt: Element) =>\n                    elt.getAttribute(\"im-re-append\") === \"true\",\n                shouldRemove: noOp,\n                afterHeadMorphed: noOp,\n            },\n            config.head,\n        ),\n    };\n}\n\nfunction isIdSetMatch(node1: Element, node2: Element, ctx: any) {\n    if (!node1 || !node2) return false;\n\n    if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n        if (node1?.id?.length && node1.id === node2.id) return true;\n\n        return getIdIntersectionCount(ctx, node1, node2) > 0;\n    }\n    return false;\n}\n\nfunction isSoftMatch(node1: Element, node2: Element) {\n    if (!node1 || !node2) return false;\n\n    return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName;\n}\n\nfunction removeNodesBetween(\n    startInclusive: Element,\n    endExclusive: Element,\n    ctx: any,\n) {\n    while (startInclusive !== endExclusive) {\n        const tempNode = startInclusive;\n        startInclusive = startInclusive?.nextSibling as Element;\n        if (!tempNode) {\n            throw new Error(\"tempNode is null\");\n        }\n        removeNode(tempNode, ctx);\n    }\n    removeIdsFromConsideration(ctx, endExclusive);\n    return endExclusive.nextSibling as Element | null;\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential id match\n// for the newChild.  We stop if we find a potential id match for the new child OR\n// if the number of potential id matches we are discarding is greater than the\n// potential id matches for the new child\n//=============================================================================\nfunction findIdSetMatch(\n    newContent: Element,\n    oldParent: Element,\n    newChild: Element,\n    insertionPoint: Element,\n    ctx: any,\n) {\n    // max id matches we are willing to discard in our search\n    const newChildPotentialIdCount = getIdIntersectionCount(\n        ctx,\n        newChild,\n        oldParent,\n    );\n\n    let potentialMatch: Element | null = null;\n\n    // only search forward if there is a possibility of an id match\n    if (newChildPotentialIdCount > 0) {\n        potentialMatch = insertionPoint;\n        // if there is a possibility of an id match, scan forward\n        // keep track of the potential id match count we are discarding (the\n        // newChildPotentialIdCount must be greater than this to make it likely\n        // worth it)\n        let otherMatchCount = 0;\n        while (potentialMatch != null) {\n            // If we have an id match, return the current potential match\n            if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n                return potentialMatch;\n            }\n\n            // computer the other potential matches of this new content\n            otherMatchCount += getIdIntersectionCount(\n                ctx,\n                potentialMatch,\n                newContent,\n            );\n            if (otherMatchCount > newChildPotentialIdCount) {\n                // if we have more potential id matches in _other_ content, we\n                // do not have a good candidate for an id match, so return null\n                return null;\n            }\n\n            // advanced to the next old content child\n            potentialMatch = potentialMatch.nextSibling as Element | null;\n        }\n    }\n    return potentialMatch;\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential soft match\n// for the newChild.  We stop if we find a potential soft match for the new child OR\n// if we find a potential id match in the old parents children OR if we find two\n// potential soft matches for the next two pieces of new content\n//=============================================================================\nfunction findSoftMatch(\n    newContent: Element,\n    newChild: Element,\n    insertionPoint: Element,\n    ctx: any,\n) {\n    let potentialSoftMatch = insertionPoint as Element | null;\n    let nextSibling = newChild.nextSibling as Element | null;\n\n    let siblingSoftMatchCount = 0;\n\n    while (potentialSoftMatch && nextSibling) {\n        if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n            // the current potential soft match has a potential id set match with the remaining new\n            // content so bail out of looking\n            return null;\n        }\n\n        // if we have a soft match with the current node, return it\n        if (isSoftMatch(newChild, potentialSoftMatch)) {\n            return potentialSoftMatch;\n        }\n\n        if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n            // the next new node has a soft match with this node, so\n            // increment the count of future soft matches\n            siblingSoftMatchCount++;\n            nextSibling = nextSibling.nextSibling as Element | null;\n\n            // If there are two future soft matches, bail to allow the siblings to soft match\n            // so that we don't consume future soft matches for the sake of the current node\n            if (siblingSoftMatchCount >= 2) {\n                return null;\n            }\n        }\n\n        // advanced to the next old content child\n        potentialSoftMatch = potentialSoftMatch.nextSibling as Element | null;\n    }\n\n    return potentialSoftMatch;\n}\n\nconst parser = new DOMParser();\nfunction parseContent(newContent: string) {\n    // remove svgs to avoid false-positive matches on head, etc.\n    const contentWithSvgsRemoved = newContent.replace(\n        /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n        \"\",\n    );\n\n    // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n    if (\n        contentWithSvgsRemoved.match(/<\\/html>/) ||\n        contentWithSvgsRemoved.match(/<\\/head>/) ||\n        contentWithSvgsRemoved.match(/<\\/body>/)\n    ) {\n        const content = parser.parseFromString(newContent, \"text/html\");\n        // if it is a full HTML document, return the document itself as the parent container\n        if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n            generatedByIdiomorphId.add(content);\n            return content;\n        } else {\n            // otherwise return the html element as the parent container\n            let Element = content.firstChild;\n            if (Element) {\n                generatedByIdiomorphId.add(Element);\n                return Element as Element;\n            } else {\n                return null;\n            }\n        }\n    } else {\n        // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n        // deal with touchy tags like tr, tbody, etc.\n        const responseDoc = parser.parseFromString(\n            `<body><template>${newContent}</template></body>`,\n            \"text/html\",\n        );\n        const content = responseDoc.body.querySelector(\"template\")?.content;\n        if (!content) {\n            throw new Error(\"content is null\");\n        }\n        generatedByIdiomorphId.add(content);\n        return content;\n    }\n}\n\nfunction normalizeContent(newContent: Element) {\n    if (newContent == null) {\n        // noinspection UnnecessaryLocalVariableJS\n        const dummyParent = document.createElement(\"div\");\n        return dummyParent;\n    } else if (generatedByIdiomorphId.has(newContent)) {\n        // the template tag created by idiomorph parsing can serve as a dummy parent\n        return newContent;\n    } else if (newContent instanceof Node) {\n        // a single node is added as a child to a dummy parent\n        const dummyParent = document.createElement(\"div\");\n        dummyParent.append(newContent);\n        return dummyParent;\n    } else {\n        // all nodes in the array or Element collection are consolidated under\n        // a single dummy parent element\n        const dummyParent = document.createElement(\"div\");\n        for (const elt of [...newContent]) {\n            dummyParent.append(elt);\n        }\n        return dummyParent;\n    }\n}\n\nfunction insertSiblings(\n    previousSibling?: Element,\n    morphedNode?: Element,\n    nextSibling?: Element,\n) {\n    const stack = [];\n    const added = [];\n    while (previousSibling) {\n        stack.push(previousSibling);\n        previousSibling = previousSibling.previousSibling as Element;\n    }\n    while (stack.length > 0) {\n        const node = stack.pop()!;\n        added.push(node); // push added preceding siblings on in order and insert\n        morphedNode?.parentElement?.insertBefore(node, morphedNode);\n    }\n    added.push(morphedNode);\n    while (nextSibling) {\n        stack.push(nextSibling);\n        added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n        nextSibling = nextSibling.nextSibling as Element;\n    }\n    while (stack.length) {\n        morphedNode?.parentElement?.insertBefore(\n            stack.pop()!,\n            morphedNode.nextSibling,\n        );\n    }\n    return added;\n}\n\nfunction findBestNodeMatch(newContent: Element, oldNode: Element, ctx: any) {\n    let currentElement = newContent.firstChild as Element | null;\n    let bestElement = currentElement;\n    let score = 0;\n    while (currentElement) {\n        let newScore = scoreElement(currentElement, oldNode, ctx);\n        if (newScore > score) {\n            bestElement = currentElement;\n            score = newScore;\n        }\n        currentElement = currentElement.nextSibling as Element | null;\n    }\n    return bestElement;\n}\n\nfunction scoreElement(node1: Element, node2: Element, ctx: any) {\n    if (isSoftMatch(node1, node2)) {\n        return 0.5 + getIdIntersectionCount(ctx, node1, node2);\n    }\n    return 0;\n}\n\nfunction removeNode(tempNode: Element, ctx: any) {\n    removeIdsFromConsideration(ctx, tempNode);\n    if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;\n\n    tempNode.remove();\n    ctx.callbacks.afterNodeRemoved(tempNode);\n}\n\n//=============================================================================\n// ID Set Functions\n//=============================================================================\n\nfunction isIdInConsideration(ctx: any, id: string) {\n    return !ctx.deadIds.has(id);\n}\n\nfunction idIsWithinNode(ctx: any, id: string, targetNode: Element) {\n    return ctx.idMap.get(targetNode)?.has(id) || false;\n}\n\nfunction removeIdsFromConsideration(ctx: any, node: Element) {\n    const idSet = ctx.idMap.get(node);\n    if (!idSet) return;\n    for (const id of idSet) {\n        ctx.deadIds.add(id);\n    }\n}\n\nfunction getIdIntersectionCount(ctx: any, node1: Element, node2: Element) {\n    const sourceSet = ctx.idMap.get(node1);\n    if (!sourceSet) return 0;\n\n    let matchCount = 0;\n    for (const id of sourceSet) {\n        // a potential match is an id in the source and potentialIdsSet, but\n        // that has not already been merged into the DOM\n        if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n            ++matchCount;\n        }\n    }\n    return matchCount;\n}\n\n/**\n * A bottom up algorithm that finds all elements with ids inside of the node\n * argument and populates id sets for those nodes and all their parents, generating\n * a set of ids contained within all nodes for the entire hierarchy in the DOM\n *\n * @param node {Element}\n * @param {Map<Node, Set<String>>} idMap\n */\nfunction populateIdMapForNode(node: Element, idMap: Map<Element, Set<string>>) {\n    const nodeParent = node.parentElement;\n    // find all elements with an id property\n    const idElements = node.querySelectorAll(\"[id]\");\n    for (const elt of idElements) {\n        let current = elt as Element | null;\n        // walk up the parent hierarchy of that element, adding the id\n        // of element to the parent's id set\n        while (current !== nodeParent && !!current) {\n            let idSet = idMap.get(current);\n            // if the id set doesn't exist, create it and insert it in the  map\n            if (idSet == null) {\n                idSet = new Set();\n                idMap.set(current, idSet);\n            }\n            idSet.add(elt.id);\n            current = current.parentElement;\n        }\n    }\n}\n\n/**\n * This function computes a map of nodes to all ids contained within that node (inclusive of the\n * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n * to contribute to a parent nodes matching.\n *\n * @param {Element} oldContent  the old content that will be morphed\n * @param {Element} newContent  the new content to morph to\n * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n */\nfunction createIdMap(oldContent: Element, newContent: Element) {\n    const idMap = new Map();\n    populateIdMapForNode(oldContent, idMap);\n    populateIdMapForNode(newContent, idMap);\n    return idMap;\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:cloud-download\n// Slug: Use Server-Sent Events to fetch data from a server using the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { InitContext, WatcherPlugin } from \"../../../../engine\";\nimport {\n    docWithViewTransitionAPI,\n    supportsViewTransitions,\n} from \"../../../../utils/view-transitions\";\nimport { idiomorph } from \"../../../../vendored/idiomorph\";\nimport {\n    datastarSSEEventWatcher,\n    DEFAULT_SETTLE_DURATION_RAW,\n    SETTLING_CLASS,\n    SWAPPING_CLASS,\n} from \"./sseShared\";\n\nconst DEFAULT_MERGE_MODE: FragmentMergeMode = \"morph\";\nconst DEFAULT_USE_VIEW_TRANSITION = \"false\";\n\nconst FragmentMergeModes = {\n    MorphElement: \"morph\",\n    InnerElement: \"inner\",\n    OuterElement: \"outer\",\n    PrependElement: \"prepend\",\n    AppendElement: \"append\",\n    BeforeElement: \"before\",\n    AfterElement: \"after\",\n    UpsertAttributes: \"upsertAttributes\",\n} as const;\nexport type FragmentMergeMode =\n    (typeof FragmentMergeModes)[keyof typeof FragmentMergeModes];\n\nconst name = \"mergeFragments\";\nexport const MergeFragments: WatcherPlugin = {\n    pluginType: \"effect\",\n    name: name,\n    onGlobalInit: async (ctx) => {\n        const fragmentContainer = document.createElement(\"template\");\n        datastarSSEEventWatcher(ctx, name, ({\n            fragment = \"<div></div>\",\n            selector = \"\",\n            mergeMode = DEFAULT_MERGE_MODE,\n            settleDuration: settleDurationRaw = DEFAULT_SETTLE_DURATION_RAW,\n            useViewTransition: useViewTransitionRaw =\n                DEFAULT_USE_VIEW_TRANSITION,\n        }) => {\n            const settleDuration = parseInt(settleDurationRaw);\n            const useViewTransition = useViewTransitionRaw === \"true\";\n\n            fragmentContainer.innerHTML = fragment.trim();\n            const fragments = [...fragmentContainer.content.children];\n            fragments.forEach((fragment) => {\n                if (!(fragment instanceof Element)) {\n                    throw new Error(`No fragment found`);\n                }\n\n                const selectorOrID = selector ||\n                    `#${fragment.getAttribute(\"id\")}`;\n                const targets = document.querySelectorAll(selectorOrID) ||\n                    [];\n                const allTargets = [...targets];\n                if (!allTargets.length) {\n                    throw new Error(`No targets found for ${selector}`);\n                }\n\n                if (supportsViewTransitions && useViewTransition) {\n                    docWithViewTransitionAPI.startViewTransition(() =>\n                        applyToTargets(\n                            ctx,\n                            mergeMode,\n                            settleDuration,\n                            fragment,\n                            allTargets,\n                        )\n                    );\n                } else {\n                    applyToTargets(\n                        ctx,\n                        mergeMode,\n                        settleDuration,\n                        fragment,\n                        allTargets,\n                    );\n                }\n            });\n        });\n    },\n};\n\nfunction applyToTargets(\n    ctx: InitContext,\n    mergeMode: string,\n    settleDuration: number,\n    fragment: Element,\n    capturedTargets: Element[],\n) {\n    for (const initialTarget of capturedTargets) {\n        initialTarget.classList.add(SWAPPING_CLASS);\n        const originalHTML = initialTarget.outerHTML;\n        let modifiedTarget = initialTarget;\n        switch (mergeMode) {\n            case FragmentMergeModes.MorphElement:\n                const result = idiomorph(\n                    modifiedTarget,\n                    fragment,\n                    {\n                        callbacks: {\n                            beforeNodeRemoved: (\n                                oldNode: Element,\n                                _: Element,\n                            ) => {\n                                ctx.cleanupElementRemovals(\n                                    oldNode,\n                                );\n                                return true;\n                            },\n                        },\n                    },\n                );\n                if (!result?.length) {\n                    throw new Error(`No morph result `);\n                }\n                const first = result[0] as Element;\n                modifiedTarget = first;\n                break;\n            case FragmentMergeModes.InnerElement:\n                // Replace the contents of the target element with the response\n                modifiedTarget.innerHTML = fragment.innerHTML;\n                break;\n            case FragmentMergeModes.OuterElement:\n                // Replace the entire target element with the response\n                modifiedTarget.replaceWith(fragment);\n                break;\n            case FragmentMergeModes.PrependElement:\n                // Insert the response before the first child of the target element\n                modifiedTarget.prepend(fragment);\n                break;\n            case FragmentMergeModes.AppendElement:\n                // Insert the response after the last child of the target element\n                modifiedTarget.append(fragment);\n                break;\n            case FragmentMergeModes.BeforeElement:\n                // Insert the response before the target element\n                modifiedTarget.before(fragment);\n                break;\n            case FragmentMergeModes.AfterElement:\n                // Insert the response after the target element\n                modifiedTarget.after(fragment);\n                break;\n            case FragmentMergeModes.UpsertAttributes:\n                // Upsert the attributes of the target element\n                fragment.getAttributeNames().forEach(\n                    (attrName) => {\n                        const value = fragment.getAttribute(\n                            attrName,\n                        )!;\n                        modifiedTarget.setAttribute(\n                            attrName,\n                            value,\n                        );\n                    },\n                );\n                break;\n            default:\n                throw new Error(\n                    `Unknown merge type: ${mergeMode}`,\n                );\n        }\n        ctx.cleanupElementRemovals(modifiedTarget);\n        modifiedTarget.classList.add(SWAPPING_CLASS);\n\n        ctx.applyPlugins(document.body);\n\n        setTimeout(() => {\n            initialTarget.classList.remove(SWAPPING_CLASS);\n            modifiedTarget.classList.remove(SWAPPING_CLASS);\n        }, settleDuration);\n\n        const revisedHTML = modifiedTarget.outerHTML;\n\n        if (originalHTML !== revisedHTML) {\n            modifiedTarget.classList.add(SETTLING_CLASS);\n            setTimeout(() => {\n                modifiedTarget.classList.remove(\n                    SETTLING_CLASS,\n                );\n            }, settleDuration);\n        }\n    }\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:settings-input-antenna\n// Slug: Merge fine grain signals store data from a server using the Datastar SDK interface\n// Description: Merge store data from a server using the Datastar SDK interface\n\nimport { InitExpressionFunction, WatcherPlugin } from \"../../../../engine\";\nimport { storeFromPossibleContents } from \"../../../../utils/signals\";\nimport { datastarSSEEventWatcher } from \"./sseShared\";\n\nconst name = \"mergeStore\";\nexport const MergeStore: WatcherPlugin = {\n    pluginType: \"effect\",\n    name,\n    onGlobalInit: async (ctx) => {\n        datastarSSEEventWatcher(ctx, name, ({\n            store = \"{}\",\n            onlyIfMissing: onlyIfMissingRaw = \"false\",\n        }) => {\n            const onlyIfMissing = onlyIfMissingRaw.trim() === \"true\";\n\n            const fnContents =\n                ` return Object.assign({...ctx.store()}, ${store})`;\n            try {\n                const fn = new Function(\n                    \"ctx\",\n                    fnContents,\n                ) as InitExpressionFunction;\n                const possibleMergeStore = fn(ctx);\n                const actualMergeStore = storeFromPossibleContents(\n                    ctx.store(),\n                    possibleMergeStore,\n                    onlyIfMissing,\n                );\n                ctx.mergeStore(actualMergeStore);\n                ctx.applyPlugins(document.body);\n            } catch (e) {\n                console.log(fnContents);\n                console.error(e);\n                debugger;\n            }\n        });\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:settings-input-antenna\n// Slug: Merge fine grain signals store data from a server using the Datastar SDK interface\n// Description: Merge store data from a server using the Datastar SDK interface\n\nimport { WatcherPlugin } from \"../../../../engine\";\nimport {\n    docWithViewTransitionAPI,\n    supportsViewTransitions,\n} from \"../../../../utils/view-transitions\";\nimport {\n    datastarSSEEventWatcher,\n    DEFAULT_SETTLE_DURATION_RAW,\n    SWAPPING_CLASS,\n} from \"./sseShared\";\n\nconst name = \"removeFragments\";\nexport const RemoveFragments: WatcherPlugin = {\n    pluginType: \"effect\",\n    name,\n    onGlobalInit: async (ctx) => {\n        datastarSSEEventWatcher(ctx, name, ({\n            selector,\n            settleDuration: settleDurationRaw = DEFAULT_SETTLE_DURATION_RAW,\n            useViewTransition: useViewTransitionRaw = \"false\",\n        }) => {\n            if (!!!selector.length) {\n                throw new Error(\n                    \"No selector provided for remove-fragments\",\n                );\n            }\n\n            const settleDuration = parseInt(settleDurationRaw);\n            const useViewTransition = useViewTransitionRaw === \"true\";\n            const removeTargets = document.querySelectorAll(selector);\n\n            const applyToTargets = () => {\n                for (const target of removeTargets) {\n                    target.classList.add(SWAPPING_CLASS);\n                }\n\n                setTimeout(() => {\n                    for (const target of removeTargets) {\n                        target.remove();\n                    }\n                }, settleDuration);\n            };\n\n            if (supportsViewTransitions && useViewTransition) {\n                docWithViewTransitionAPI.startViewTransition(() =>\n                    applyToTargets()\n                );\n            } else {\n                applyToTargets();\n            }\n        });\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:settings-input-antenna\n// Slug: Merge fine grain signals store data from a server using the Datastar SDK interface\n// Description: Merge store data from a server using the Datastar SDK interface\n\nimport { WatcherPlugin } from \"../../../../engine\";\nimport { datastarSSEEventWatcher } from \"./sseShared\";\n\nconst name = \"removeSignals\";\nexport const RemoveSignals: WatcherPlugin = {\n    pluginType: \"effect\",\n    name,\n    onGlobalInit: async (ctx) => {\n        datastarSSEEventWatcher(ctx, name, ({ paths: pathsRaw = \"\" }) => {\n            // replace all whitespace with a single space\n            pathsRaw = pathsRaw.replaceAll(/\\s+/g, \" \");\n            if (!!!pathsRaw?.length) {\n                throw new Error(\n                    \"No paths provided for remove-signals\",\n                );\n            }\n\n            const paths = pathsRaw.split(\" \");\n            ctx.removeFromStore(...paths);\n        });\n    },\n};\n", "import { Datastar } from \"../engine\";\nimport { IsFetching } from \"../plugins/official/actions/backend/isFetching\";\nimport { RemoteSignals } from \"../plugins/official/actions/backend/remote\";\nimport { DeleteSSE } from \"../plugins/official/actions/backend/sseDelete\";\nimport { GetSSE } from \"../plugins/official/actions/backend/sseGet\";\nimport { PatchSSE } from \"../plugins/official/actions/backend/ssePatch\";\nimport { PostSSE } from \"../plugins/official/actions/backend/ssePost\";\nimport { PutSSE } from \"../plugins/official/actions/backend/ssePut\";\nimport { Clipboard } from \"../plugins/official/actions/dom/clipboard\";\nimport { RefAction } from \"../plugins/official/actions/dom/ref\";\nimport { SetAll } from \"../plugins/official/actions/logic/setAll\";\nimport { ToggleAll } from \"../plugins/official/actions/logic/toggleAll\";\nimport { ClampFit } from \"../plugins/official/actions/math/clampFit\";\nimport { ClampFitInt } from \"../plugins/official/actions/math/clampFitInt\";\nimport { Fit } from \"../plugins/official/actions/math/fit\";\nimport { FitInt } from \"../plugins/official/actions/math/fitInt\";\nimport { FetchIndicator } from \"../plugins/official/attributes/backend/fetchIndicator\";\nimport { Header } from \"../plugins/official/attributes/backend/header\";\nimport { ReplaceUrl } from \"../plugins/official/attributes/backend/replaceUrl\";\nimport { Bind } from \"../plugins/official/attributes/dom/bind\";\nimport { Class } from \"../plugins/official/attributes/dom/class\";\nimport { Model } from \"../plugins/official/attributes/dom/model\";\nimport { On } from \"../plugins/official/attributes/dom/on\";\nimport { RefAttribute } from \"../plugins/official/attributes/dom/ref\";\nimport { Text } from \"../plugins/official/attributes/dom/text\";\nimport { Persist } from \"../plugins/official/attributes/storage/persist\";\nimport { Intersection } from \"../plugins/official/attributes/visibility/intersects\";\nimport { ScrollIntoView } from \"../plugins/official/attributes/visibility/scrollIntoView\";\nimport { Show } from \"../plugins/official/attributes/visibility/show\";\nimport { Teleport } from \"../plugins/official/attributes/visibility/teleport\";\nimport { ViewTransition } from \"../plugins/official/attributes/visibility/viewTransition\";\nimport { DispatchCustomEvent } from \"../plugins/official/watchers/backend/sseDispatchCustomEvent\";\nimport { ExecuteJS } from \"../plugins/official/watchers/backend/sseExecuteJS\";\nimport { MergeFragments } from \"../plugins/official/watchers/backend/sseMergeFragment\";\nimport { MergeStore } from \"../plugins/official/watchers/backend/sseMergeSignals\";\nimport { RemoveFragments } from \"../plugins/official/watchers/backend/sseRemoveFragments\";\nimport { RemoveSignals } from \"../plugins/official/watchers/backend/sseRemoveSignals\";\n\nDatastar.load(\n    // actions/backend\n    IsFetching,\n    RemoteSignals,\n    DeleteSSE,\n    GetSSE,\n    PatchSSE,\n    PostSSE,\n    PutSSE,\n    // actions/dom\n    Clipboard,\n    RefAction,\n    // actions/logic\n    SetAll,\n    ToggleAll,\n    // actions/math\n    ClampFit,\n    ClampFitInt,\n    Fit,\n    FitInt,\n    // attributes/backend\n    FetchIndicator,\n    Header,\n    ReplaceUrl,\n    // attributes/dom\n    Bind,\n    Class,\n    Model,\n    On,\n    RefAttribute,\n    Text,\n    // attributes/storage\n    Persist,\n    // attributes/visibility\n    Intersection,\n    ScrollIntoView,\n    Show,\n    Teleport,\n    ViewTransition,\n    // effects\n    MergeFragments,\n    MergeStore,\n    RemoveFragments,\n    RemoveSignals,\n    ExecuteJS,\n    DispatchCustomEvent,\n);\n"],
  "mappings": "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",
  "names": ["Computed", "ctx", "store", "remoteSignals", "obj", "res", "k", "v", "storeFromPossibleContents", "currentStore", "contents", "hasIfMissing", "actual", "key", "currentValue", "Store", "groups", "whole", "ctx", "possibleMergeStore", "actualMergeStore", "storeFromPossibleContents", "validJSIdentifier", "validNestedJSIdentifier", "wholePrefixSuffix", "rune", "prefix", "suffix", "nestable", "identifier", "ActionsProcessor", "wholePrefixSuffix", "action", "args", "withCtx", "x", "argsJoined", "SignalsProcessor", "wholePrefixSuffix", "groups", "signal", "method", "prefix", "parts", "methodName", "nestedSignal", "elemToSelector", "elm", "names", "idAttr", "c", "e", "nodeHTMLorSVGElement", "node", "scrollIntoView", "el", "opts", "shouldFocus", "BRAND_SYMBOL", "RUNNING", "NOTIFIED", "OUTDATED", "DISPOSED", "HAS_ERROR", "TRACKING", "startBatch", "batchDepth", "endBatch", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "needsToRecompute", "err", "batch", "fn", "evalContext", "batchedEffect", "batchDepth", "batchIteration", "globalVersion", "addDependency", "signal", "evalContext", "node", "TRACKING", "Signal", "value", "BRAND_SYMBOL", "prev", "next", "fn", "effect", "prevContext", "startBatch", "endBatch", "needsToRecompute", "target", "prepareSources", "rollbackNode", "cleanupSources", "head", "Computed", "OUTDATED", "NOTIFIED", "RUNNING", "HAS_ERROR", "err", "computed", "cleanupEffect", "cleanup", "DISPOSED", "disposeEffect", "endEffect", "Effect", "finish", "DeepSignal", "getValue", "payload", "batch", "setValue", "deepSignal", "initialValue", "acc", "key", "value", "iKey", "signal", "peek", "Signal", "apply", "target", "patchItem", "targetResult", "k", "DATASTAR", "DATASTAR_EVENT", "VERSION", "isPreprocessorPlugin", "p", "isEffectPlugin", "isAttributePlugin", "isActionPlugin", "Engine", "deepSignal", "signal", "computed", "effect", "_mutationList", "_observer", "VERSION", "pluginsToLoad", "allLoadedPlugins", "plugin", "requiredPluginType", "globalInitializer", "category", "subcategory", "type", "target", "message", "opts", "contents", "elemToSelector", "evt", "DATASTAR_EVENT", "element", "removalSet", "removal", "mergeStore", "revisedStore", "apply", "marshalledStore", "keys", "key", "parts", "currentID", "subStore", "i", "part", "path", "value", "last", "name", "rootElement", "appliedProcessors", "pi", "el", "rawKey", "rawExpression", "expression", "lowerCaseTag", "r", "t", "keyRaw", "modifiersWithArgsArr", "modifiersArr", "m", "label", "args", "modifier", "modifiers", "splitRegex", "processors", "processor", "expressionParts", "revisedParts", "exp", "revised", "matches", "match", "groups", "whole", "ctx", "statements", "s", "joined", "fnContent", "argumentNames", "fn", "e", "err", "store", "callback", "isSignal", "Signal", "hasChildren", "siblingOffset", "nodeHTMLorSVGElement", "ds", "Engine", "ActionsProcessor", "SignalsProcessor", "Store", "Computed", "Datastar", "IsFetching", "ctx", "selector", "indicators", "indicatorsVisible", "indicator", "val", "indicatorVisible", "RemoteSignals", "ctx", "remoteSignals", "getBytes", "stream", "onChunk", "reader", "result", "getLines", "onLine", "buffer", "position", "fieldLength", "discardTrailingNewline", "arr", "concat", "bufLength", "lineStart", "lineEnd", "getMessages", "onId", "onRetry", "onMessage", "message", "newMessage", "decoder", "line", "field", "valueOffset", "value", "retry", "a", "b", "res", "EventStreamContentType", "DefaultRetryInterval", "LastEventId", "fetchEventSource", "input", "inputSignal", "inputHeaders", "inputOnOpen", "onmessage", "onclose", "onerror", "openWhenHidden", "inputFetch", "retryScaler", "retryMaxWaitMs", "retryMaxCount", "rest", "resolve", "reject", "retries", "headers", "curRequestController", "onVisibilityChange", "create", "retryInterval", "retryTimer", "dispose", "fetch", "onopen", "defaultOnOpen", "response", "getBytes", "getLines", "getMessages", "id", "retry", "err", "interval", "innerErr", "contentType", "INDICATOR_CLASS", "DATASTAR", "INDICATOR_LOADING_CLASS", "FetchIndicator", "style", "ctx", "c", "s", "indicators", "indicator", "kebabize", "str", "$", "ofs", "DATASTAR_SSE_EVENT", "DEFAULT_SETTLE_DURATION_RAW", "SETTLING_CLASS", "DATASTAR", "SWAPPING_CLASS", "datastarSSEEventWatcher", "ctx", "name", "fn", "kebabName", "kebabize", "event", "argsRaw", "DEFAULT_SETTLE_DURATION", "DEFAULT_SETTLE_DURATION_RAW", "isWrongContent", "err", "sendSSERequest", "method", "ctx", "url", "onlyRemotes", "currentStore", "store", "remoteSignals", "storeJSON", "sendFromElement", "indicatorElements", "indicatorsVisible", "indicator", "indicatorVisibleIndex", "indicatorVisible", "indicatorsVisibleNew", "INDICATOR_CLASS", "INDICATOR_LOADING_CLASS", "urlInstance", "req", "DATASTAR", "evt", "type", "argsRawLines", "lines", "line", "colonIndex", "key", "argLines", "value", "argsRaw", "datastarSSEEvent", "DATASTAR_SSE_EVENT", "indicatorCleanupPromises", "e", "queryParams", "headers", "revisedURL", "fetchEventSource", "DeleteSSE", "sendSSERequest", "GetSSE", "sendSSERequest", "PatchSSE", "sendSSERequest", "PostSSE", "sendSSERequest", "PutSSE", "sendSSERequest", "Clipboard", "_", "text", "RefAction", "ctx", "text", "selectorSignal", "selector", "el", "SetAll", "ctx", "regexp", "newValue", "re", "name", "signal", "ToggleAll", "ctx", "regexp", "re", "name", "signal", "ClampFit", "_", "v", "oldMin", "oldMax", "newMin", "newMax", "ClampFitInt", "_", "v", "oldMin", "oldMax", "newMin", "newMax", "Fit", "_", "v", "oldMin", "oldMax", "newMin", "newMax", "FitInt", "_", "v", "oldMin", "oldMax", "newMin", "newMax", "Header", "ctx", "headers", "key", "value", "ReplaceUrl", "ctx", "value", "baseUrl", "url", "Bind", "ctx", "key", "kebabize", "value", "v", "Class", "ctx", "classes", "k", "v", "clss", "dataURIRegex", "updateModelEvents", "Model", "groups", "whole", "ctx", "el", "expression", "signal", "tnl", "isInput", "type", "isCheckbox", "isSelect", "isRadio", "isFile", "signalName", "setInputFromSignal", "hasValue", "v", "input", "select", "opt", "cleanupSetInputFromSignal", "setSignalFromInput", "files", "allContents", "allMimes", "allNames", "f", "resolve", "reader", "match", "s", "mimeName", "nameName", "current", "selectedValues", "parts", "customElementPrefix", "eventType", "event", "argsToMs", "args", "arg", "argsHas", "defaultValue", "debounce", "callback", "wait", "leading", "trailing", "timer", "resetTimer", "args", "throttle", "waiting", "knownOnModifiers", "lastStoreMarshalled", "On", "ctx", "el", "key", "expressionFn", "target", "callback", "evt", "debounceArgs", "wait", "argsToMs", "leading", "argsHas", "trailing", "debounce", "throttleArgs", "throttle", "evtListOpts", "attrName", "eventValues", "cb", "attr", "valid", "lowerAttr", "expr", "msg", "eventName", "kebabize", "rafId", "raf", "storeValue", "remoteSignals", "current", "called", "e", "targetHTML", "isEl", "RefAttribute", "ctx", "el", "expression", "revised", "elemToSelector", "Text", "ctx", "el", "expressionFn", "res", "Persist", "ctx", "key", "DATASTAR", "expression", "keys", "parts", "part", "lastMarshalled", "storageType", "useRemote", "storeUpdateHandler", "_", "store", "remoteSignals", "newStore", "newSubstore", "subStore", "i", "lastPart", "marshalledStore", "DATASTAR_EVENT", "value", "ONCE", "HALF", "FULL", "Intersection", "ctx", "modifiers", "options", "observer", "entries", "entry", "ScrollIntoView", "el", "modifiers", "rawKey", "opts", "scrollIntoView", "DISPLAY", "NONE", "IMPORTANT", "DURATION", "SHOW_CLASS", "DATASTAR", "HIDE_CLASS", "SHOW_DURATION_TRANSITION_STYLE", "Show", "ctx", "el", "modifiers", "expressionFn", "reactivity", "priority", "showFn", "hideFn", "durationArgs", "style", "durationMs", "argsToMs", "transitionEndHandler", "classNameToRemove", "event", "PREPEND", "APPEND", "teleportParentErr", "Teleport", "ctx", "el", "modifiers", "expression", "target", "n", "nodeHTMLorSVGElement", "docWithViewTransitionAPI", "supportsViewTransitions", "ViewTransition", "hasViewTransitionMeta", "node", "meta", "ctx", "supportsViewTransitions", "el", "expressionFn", "name", "elVTASTyle", "name", "DispatchCustomEvent", "ctx", "datastarSSEEventWatcher", "eventName", "selector", "bubblesRaw", "cancelableRaw", "composedRaw", "detailJson", "elements", "composed", "bubbles", "cancelable", "detail", "event", "element", "name", "ExecuteJS", "ctx", "datastarSSEEventWatcher", "autoRemoveScriptRaw", "script", "autoRemoveScript", "scriptEl", "generatedByIdiomorphId", "idiomorph", "oldNode", "newContent", "config", "parsedContent", "parseContent", "normalizedContent", "normalizeContent", "ctx", "createMorphContext", "morphNormalizedContent", "normalizedNewContent", "oldHead", "newHead", "promises", "handleHeadElement", "morphChildren", "bestMatch", "findBestNodeMatch", "previousSibling", "nextSibling", "morphedNode", "morphOldNodeTo", "insertSiblings", "isSoftMatch", "syncNodeFrom", "newParent", "oldParent", "nextNewChild", "insertionPoint", "newChild", "removeIdsFromConsideration", "isIdSetMatch", "idSetMatch", "findIdSetMatch", "removeNodesBetween", "softMatch", "findSoftMatch", "tempNode", "removeNode", "from", "to", "type", "fromAttribute", "toAttribute", "syncAttribute", "fromValue", "toValue", "attributeName", "fAttr", "tAttr", "newHeadTag", "currentHead", "added", "removed", "preserved", "nodesToAppend", "headMergeStyle", "srcToNewHeadNodes", "newHeadChild", "currentHeadElt", "inNewContent", "isReAppended", "isPreserved", "newNode", "newElt", "resolver", "promise", "resolve", "removedElement", "noOp", "createIdMap", "elt", "node1", "node2", "getIdIntersectionCount", "startInclusive", "endExclusive", "newChildPotentialIdCount", "potentialMatch", "otherMatchCount", "potentialSoftMatch", "siblingSoftMatchCount", "parser", "contentWithSvgsRemoved", "content", "Element", "dummyParent", "stack", "node", "currentElement", "bestElement", "score", "newScore", "scoreElement", "isIdInConsideration", "id", "idIsWithinNode", "targetNode", "idSet", "sourceSet", "matchCount", "populateIdMapForNode", "idMap", "nodeParent", "idElements", "current", "oldContent", "DEFAULT_MERGE_MODE", "DEFAULT_USE_VIEW_TRANSITION", "FragmentMergeModes", "name", "MergeFragments", "ctx", "fragmentContainer", "datastarSSEEventWatcher", "fragment", "selector", "mergeMode", "settleDurationRaw", "DEFAULT_SETTLE_DURATION_RAW", "useViewTransitionRaw", "settleDuration", "useViewTransition", "selectorOrID", "allTargets", "supportsViewTransitions", "docWithViewTransitionAPI", "applyToTargets", "capturedTargets", "initialTarget", "SWAPPING_CLASS", "originalHTML", "modifiedTarget", "result", "idiomorph", "oldNode", "_", "attrName", "value", "revisedHTML", "SETTLING_CLASS", "name", "MergeStore", "ctx", "datastarSSEEventWatcher", "store", "onlyIfMissingRaw", "onlyIfMissing", "fnContents", "possibleMergeStore", "actualMergeStore", "storeFromPossibleContents", "e", "name", "RemoveFragments", "ctx", "datastarSSEEventWatcher", "selector", "settleDurationRaw", "DEFAULT_SETTLE_DURATION_RAW", "useViewTransitionRaw", "settleDuration", "useViewTransition", "removeTargets", "applyToTargets", "target", "SWAPPING_CLASS", "supportsViewTransitions", "docWithViewTransitionAPI", "name", "RemoveSignals", "ctx", "datastarSSEEventWatcher", "pathsRaw", "paths", "Datastar", "IsFetching", "RemoteSignals", "DeleteSSE", "GetSSE", "PatchSSE", "PostSSE", "PutSSE", "Clipboard", "RefAction", "SetAll", "ToggleAll", "ClampFit", "ClampFitInt", "Fit", "FitInt", "FetchIndicator", "Header", "ReplaceUrl", "Bind", "Class", "Model", "On", "RefAttribute", "Text", "Persist", "Intersection", "ScrollIntoView", "Show", "Teleport", "ViewTransition", "MergeFragments", "MergeStore", "RemoveFragments", "RemoveSignals", "ExecuteJS", "DispatchCustomEvent"]
}
