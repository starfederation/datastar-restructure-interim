{
  "version": 3,
  "sources": ["../code/ts/library/src/plugins/official/attributes/core/advice.ts", "../code/ts/library/src/engine/client_only_consts.ts", "../code/ts/library/src/plugins/official/attributes/core/computed.ts", "../code/ts/library/src/utils/signals.ts", "../code/ts/library/src/plugins/official/attributes/core/store.ts", "../code/ts/library/src/utils/regex.ts", "../code/ts/library/src/plugins/official/preprocessors/core/actions.ts", "../code/ts/library/src/plugins/official/preprocessors/core/signals.ts", "../code/ts/library/src/utils/dom.ts", "../code/ts/library/src/vendored/preact-core.ts", "../code/ts/library/src/vendored/deepsignal.ts", "../code/ts/library/src/vendored/ts-merge-patch.ts", "../code/ts/library/src/engine/version.ts", "../code/ts/library/src/engine/engine.ts", "../code/ts/library/src/engine/consts.ts", "../code/ts/library/src/engine/index.ts", "../code/ts/library/src/bundles/datastar-core.ts"],
  "sourcesContent": ["// Authors: Delaney Gillilan\n// Icon: material-symbols:rocket\n// Slug: Advice\n// Description: Sage advice for the weary traveler\n\nimport { AttributePlugin } from \"../../../../engine\";\n\nexport const Star: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"star\",\n    onLoad: () => {\n        alert(\"YOU ARE PROBABLY OVERCOMPLICATING IT\");\n    },\n};\n", "export const PLUGIN_ACTION = \"action\";\nexport const PLUGIN_WATCHER = \"watcher\";\nexport const PLUGIN_PREPROCESSOR = \"preprocessor\";\nexport const PLUGIN_ATTRIBUTE = \"attribute\";\n\nexport const REMOTE = \"remote\";\nexport const LOCAL = \"local\";\nexport const SESSION = \"session\";\n", "// Authors: Delaney Gillilan\n// Icon: fluent:draw-text-24-filled\n// Slug: Create a computed signal\n// Description: This attribute creates a computed signal that updates when its dependencies change.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { PLUGIN_ATTRIBUTE } from \"../../../../engine/client_only_consts\";\n\nexport const Computed: AttributePlugin = {\n    pluginType: PLUGIN_ATTRIBUTE,\n    name: \"computed\",\n    mustNotEmptyKey: true,\n    onLoad: (ctx) => {\n        const store = ctx.store();\n        store[ctx.key] = ctx.reactivity.computed(() => {\n            return ctx.expressionFn(ctx);\n        });\n\n        return () => {\n            const store = ctx.store();\n            delete store[ctx.key];\n        };\n    },\n};\n", "export function remoteSignals(obj: Object): Object {\n    const res: Record<string, any> = {};\n\n    for (const [k, v] of Object.entries(obj)) {\n        if (k.startsWith(\"_\")) {\n            continue;\n        } else if (typeof v === \"object\" && !Array.isArray(v)) {\n            res[k] = remoteSignals(v); // recurse\n        } else {\n            res[k] = v;\n        }\n    }\n\n    return res;\n}\n\nexport function storeFromPossibleContents(\n    currentStore: any,\n    contents: any,\n    hasIfMissing: boolean,\n) {\n    const actual: any = {};\n\n    if (!hasIfMissing) {\n        Object.assign(actual, contents);\n    } else {\n        for (const key in contents) {\n            const currentValue = currentStore[key]?.value;\n            if (currentValue === undefined || currentValue === null) {\n                actual[key] = contents[key];\n            }\n        }\n    }\n\n    return actual;\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:home-storage\n// Slug: Store signals into a singleton per page\n// Description: This action stores signals into a singleton per page. This is useful for storing signals that are used across multiple components.\n\nimport {\n    AttributeContext,\n    AttributePlugin,\n    RegexpGroups,\n} from \"../../../../engine\";\nimport {\n    PLUGIN_ATTRIBUTE,\n    PLUGIN_PREPROCESSOR,\n} from \"../../../../engine/client_only_consts\";\nimport { storeFromPossibleContents } from \"../../../../utils/signals\";\n\n// Setup the global store\nexport const Store: AttributePlugin = {\n    pluginType: PLUGIN_ATTRIBUTE,\n    name: \"store\",\n    removeNewLines: true,\n    preprocessors: {\n        pre: [\n            {\n                pluginType: PLUGIN_PREPROCESSOR,\n                name: \"store\",\n                regexp: /(?<whole>.+)/g,\n                replacer: (groups: RegexpGroups) => {\n                    const { whole } = groups;\n                    return `Object.assign({...ctx.store()}, ${whole})`;\n                },\n            },\n        ],\n    },\n    allowedModifiers: new Set([\"ifmissing\"]),\n    onLoad: (ctx: AttributeContext) => {\n        const possibleMergeStore = ctx.expressionFn(ctx);\n        const actualMergeStore = storeFromPossibleContents(\n            ctx.store(),\n            possibleMergeStore,\n            ctx.modifiers.has(\"ifmissing\"),\n        );\n        ctx.mergeStore(actualMergeStore);\n\n        delete ctx.el.dataset[ctx.rawKey];\n    },\n};\n", "export const validJSIdentifier = `[a-zA-Z_$]+`;\nexport const validNestedJSIdentifier = validJSIdentifier + `[0-9a-zA-Z_$.]*`;\n\nexport function wholePrefixSuffix(\n    rune: string,\n    prefix: string,\n    suffix: string,\n    nestable = true,\n) {\n    const identifier = nestable ? validNestedJSIdentifier : validJSIdentifier;\n    return new RegExp(\n        `(?<whole>${rune}(?<${prefix}>${identifier})${suffix})`,\n        `g`,\n    );\n}\n", "import { PreprocessorPlugin, RegexpGroups } from \"../../../../engine\";\nimport { PLUGIN_PREPROCESSOR } from \"../../../../engine/client_only_consts\";\nimport { wholePrefixSuffix } from \"../../../../utils/regex\";\n\n// Replacing $action(args) with ctx.actions.action(ctx, args)\nexport const ActionsProcessor: PreprocessorPlugin = {\n    name: \"action\",\n    pluginType: PLUGIN_PREPROCESSOR,\n    regexp: wholePrefixSuffix(\n        \"\\\\$\",\n        \"action\",\n        \"(?<call>\\\\((?<args>.*)\\\\))\",\n        false,\n    ),\n    replacer: ({ action, args }: RegexpGroups) => {\n        const withCtx = [`ctx`];\n        if (args) {\n            withCtx.push(...args.split(\",\").map((x) => x.trim()));\n        }\n        const argsJoined = withCtx.join(\",\");\n        return `ctx.actions.${action}.method(${argsJoined})`;\n    },\n};\n", "import { PreprocessorPlugin, RegexpGroups } from \"../../../../engine\";\nimport { PLUGIN_PREPROCESSOR } from \"../../../../engine/client_only_consts\";\nimport { wholePrefixSuffix } from \"../../../../utils/regex\";\n\n// Replacing $signal with ctx.store.signal.value`\nexport const SignalsProcessor: PreprocessorPlugin = {\n    name: \"signal\",\n    pluginType: PLUGIN_PREPROCESSOR,\n    regexp: wholePrefixSuffix(\"\\\\$\", \"signal\", \"(?<method>\\\\([^\\\\)]*\\\\))?\"),\n    replacer: (groups: RegexpGroups) => {\n        const { signal, method } = groups;\n        const prefix = `ctx.store()`;\n        if (!method?.length) {\n            return `${prefix}.${signal}.value`;\n        }\n        const parts = signal.split(\".\");\n        const methodName = parts.pop();\n        const nestedSignal = parts.join(\".\");\n        return `${prefix}.${nestedSignal}.value.${methodName}${method}`;\n    },\n};\n", "import { HTMLorSVGElement } from \"./types\";\n\nexport function elemToSelector(\n    elm: Element | Window | Document | string | null,\n) {\n    if (!elm) return \"null\";\n    if (typeof elm === \"string\") return elm;\n    if (elm instanceof Window) return \"Window\";\n    if (elm instanceof Document) return \"Document\";\n\n    if (elm.tagName === \"BODY\") return \"BODY\";\n    const names = new Array<string>();\n    while (elm.parentElement && elm.tagName !== \"BODY\") {\n        if (elm.id) {\n            const idAttr = elm.getAttribute(\"id\");\n            if (!idAttr) {\n                throw new Error(\"Element has an ID but no ID attribute\");\n            }\n            names.unshift(\"#\" + idAttr); // getAttribute, because `elm.id` could also return a child element with name \"id\"\n            break; // Because ID should be unique, no more is needed. Remove the break, if you always want a full path.\n        } else {\n            let c = 1,\n                e = elm;\n            for (; e.previousElementSibling; e = e.previousElementSibling, c++);\n            names.unshift(elm.tagName + \":nth-child(\" + c + \")\");\n        }\n        elm = elm.parentElement;\n    }\n    return names.join(\">\");\n}\n\nexport function nodeHTMLorSVGElement(node: Node): HTMLorSVGElement | null {\n    if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\n        return null;\n    }\n    return node;\n}\n\nexport function scrollIntoView(\n    el: HTMLElement | SVGElement,\n    opts: ScrollIntoViewOptions,\n    shouldFocus = true,\n) {\n    if (!(el instanceof HTMLElement || el instanceof SVGElement)) {\n        throw new Error(\"Element not found\");\n    }\n    if (!el.tabIndex) el.setAttribute(\"tabindex\", \"0\");\n\n    el.scrollIntoView(opts);\n    if (shouldFocus) el.focus();\n}\n", "// An named symbol/brand for detecting Signal instances even when they weren't\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for(\"preact-signals\");\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n  // A source whose value the target depends on.\n  _source: Signal;\n  _prevSource?: Node;\n  _nextSource?: Node;\n\n  // A target that depends on the source and should be notified when the source changes.\n  _target: Computed | Effect;\n  _prevTarget?: Node;\n  _nextTarget?: Node;\n\n  // The version number of the source that target has last seen. We use version numbers\n  // instead of storing the source value, because source values can take arbitrary amount\n  // of memory, and computeds could hang on to them forever because they're lazily evaluated.\n  // Use the special value -1 to mark potentially unused but recyclable nodes.\n  _version: number;\n\n  // Used to remember & roll back the source's previous `._node` value when entering &\n  // exiting a new evaluation context.\n  _rollbackNode?: Node;\n};\n\nfunction startBatch() {\n  batchDepth++;\n}\n\nfunction endBatch() {\n  if (batchDepth > 1) {\n    batchDepth--;\n    return;\n  }\n\n  let error: unknown;\n  let hasError = false;\n\n  while (batchedEffect !== undefined) {\n    let effect: Effect | undefined = batchedEffect;\n    batchedEffect = undefined;\n\n    batchIteration++;\n\n    while (effect !== undefined) {\n      const next: Effect | undefined = effect._nextBatchedEffect;\n      effect._nextBatchedEffect = undefined;\n      effect._flags &= ~NOTIFIED;\n\n      if (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n        try {\n          effect._callback();\n        } catch (err) {\n          if (!hasError) {\n            error = err;\n            hasError = true;\n          }\n        }\n      }\n      effect = next;\n    }\n  }\n  batchIteration = 0;\n  batchDepth--;\n\n  if (hasError) {\n    throw error;\n  }\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n  if (batchDepth > 0) {\n    return fn();\n  }\n  /*@__INLINE__**/ startBatch();\n  try {\n    return fn();\n  } finally {\n    endBatch();\n  }\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n  const prevContext = evalContext;\n  evalContext = undefined;\n  try {\n    return fn();\n  } finally {\n    evalContext = prevContext;\n  }\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n  if (evalContext === undefined) {\n    return undefined;\n  }\n\n  let node = signal._node;\n  if (node === undefined || node._target !== evalContext) {\n    /**\n     * `signal` is a new dependency. Create a new dependency node, and set it\n     * as the tail of the current context's dependency list. e.g:\n     *\n     * { A <-> B       }\n     *         \u2191     \u2191\n     *        tail  node (new)\n     *               \u2193\n     * { A <-> B <-> C }\n     *               \u2191\n     *              tail (evalContext._sources)\n     */\n    node = {\n      _version: 0,\n      _source: signal,\n      _prevSource: evalContext._sources,\n      _nextSource: undefined,\n      _target: evalContext,\n      _prevTarget: undefined,\n      _nextTarget: undefined,\n      _rollbackNode: node,\n    };\n\n    if (evalContext._sources !== undefined) {\n      evalContext._sources._nextSource = node;\n    }\n    evalContext._sources = node;\n    signal._node = node;\n\n    // Subscribe to change notifications from this dependency if we're in an effect\n    // OR evaluating a computed signal that in turn has subscribers.\n    if (evalContext._flags & TRACKING) {\n      signal._subscribe(node);\n    }\n    return node;\n  } else if (node._version === -1) {\n    // `signal` is an existing dependency from a previous evaluation. Reuse it.\n    node._version = 0;\n\n    /**\n     * If `node` is not already the current tail of the dependency list (i.e.\n     * there is a next node in the list), then make the `node` the new tail. e.g:\n     *\n     * { A <-> B <-> C <-> D }\n     *         \u2191           \u2191\n     *        node   \u250C\u2500\u2500\u2500 tail (evalContext._sources)\n     *         \u2514\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2510\n     *               \u2193     \u2193\n     * { A <-> C <-> D <-> B }\n     *                     \u2191\n     *                    tail (evalContext._sources)\n     */\n    if (node._nextSource !== undefined) {\n      node._nextSource._prevSource = node._prevSource;\n\n      if (node._prevSource !== undefined) {\n        node._prevSource._nextSource = node._nextSource;\n      }\n\n      node._prevSource = evalContext._sources;\n      node._nextSource = undefined;\n\n      evalContext._sources!._nextSource = node;\n      evalContext._sources = node;\n    }\n\n    // We can assume that the currently evaluated effect / computed signal is already\n    // subscribed to change notifications from `signal` if needed.\n    return node;\n  }\n  return undefined;\n}\n\n/**\n * The base class for plain and computed signals.\n */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style prototypes.\n// This enables better control of the transpiled output size.\ndeclare class Signal<T = any> {\n  /** @internal */\n  _value: unknown;\n\n  /**\n   * @internal\n   * Version numbers should always be >= 0, because the special value -1 is used\n   * by Nodes to signify potentially unused but recyclable nodes.\n   */\n  _version: number;\n\n  /** @internal */\n  _node?: Node;\n\n  /** @internal */\n  _targets?: Node;\n\n  constructor(value?: T);\n\n  /** @internal */\n  _refresh(): boolean;\n\n  /** @internal */\n  _subscribe(node: Node): void;\n\n  /** @internal */\n  _unsubscribe(node: Node): void;\n\n  subscribe(fn: (value: T) => void): () => void;\n\n  valueOf(): T;\n\n  toString(): string;\n\n  toJSON(): T;\n\n  peek(): T;\n\n  brand: typeof BRAND_SYMBOL;\n\n  get value(): T;\n  set value(value: T);\n}\n\n/** @internal */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style prototypes.\n// This enables better control of the transpiled output size.\nfunction Signal(this: Signal, value?: unknown) {\n  this._value = value;\n  this._version = 0;\n  this._node = undefined;\n  this._targets = undefined;\n}\n\nSignal.prototype.brand = BRAND_SYMBOL;\n\nSignal.prototype._refresh = function () {\n  return true;\n};\n\nSignal.prototype._subscribe = function (node) {\n  if (this._targets !== node && node._prevTarget === undefined) {\n    node._nextTarget = this._targets;\n    if (this._targets !== undefined) {\n      this._targets._prevTarget = node;\n    }\n    this._targets = node;\n  }\n};\n\nSignal.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the signal has any subscribers to begin with.\n  if (this._targets !== undefined) {\n    const prev = node._prevTarget;\n    const next = node._nextTarget;\n    if (prev !== undefined) {\n      prev._nextTarget = next;\n      node._prevTarget = undefined;\n    }\n    if (next !== undefined) {\n      next._prevTarget = prev;\n      node._nextTarget = undefined;\n    }\n    if (node === this._targets) {\n      this._targets = next;\n    }\n  }\n};\n\nSignal.prototype.subscribe = function (fn) {\n  return effect(() => {\n    const value = this.value;\n\n    const prevContext = evalContext;\n    evalContext = undefined;\n    try {\n      fn(value);\n    } finally {\n      evalContext = prevContext;\n    }\n  });\n};\n\nSignal.prototype.valueOf = function () {\n  return this.value;\n};\n\nSignal.prototype.toString = function () {\n  return this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n  return this.value;\n};\n\nSignal.prototype.peek = function () {\n  const prevContext = evalContext;\n  evalContext = undefined;\n  try {\n    return this.value;\n  } finally {\n    evalContext = prevContext;\n  }\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n  get(this: Signal) {\n    const node = addDependency(this);\n    if (node !== undefined) {\n      node._version = this._version;\n    }\n    return this._value;\n  },\n  set(this: Signal, value) {\n    if (value !== this._value) {\n      if (batchIteration > 100) {\n        throw new Error(\"Cycle detected\");\n      }\n\n      this._value = value;\n      this._version++;\n      globalVersion++;\n\n      /**@__INLINE__*/ startBatch();\n      try {\n        for (\n          let node = this._targets;\n          node !== undefined;\n          node = node._nextTarget\n        ) {\n          node._target._notify();\n        }\n      } finally {\n        endBatch();\n      }\n    }\n  },\n});\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T): Signal<T>;\nexport function signal<T = undefined>(): Signal<T | undefined>;\nexport function signal<T>(value?: T): Signal<T> {\n  return new Signal(value);\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n  // Check the dependencies for changed values. The dependency list is already\n  // in order of use. Therefore if multiple dependencies have changed values, only\n  // the first used dependency is re-evaluated at this point.\n  for (\n    let node = target._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    // If there's a new version of the dependency before or after refreshing,\n    // or the dependency has something blocking it from refreshing at all (e.g. a\n    // dependency cycle), then we need to recompute.\n    if (\n      node._source._version !== node._version ||\n      !node._source._refresh() ||\n      node._source._version !== node._version\n    ) {\n      return true;\n    }\n  }\n  // If none of the dependencies have changed values since last recompute then\n  // there's no need to recompute.\n  return false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n  /**\n   * 1. Mark all current sources as re-usable nodes (version: -1)\n   * 2. Set a rollback node if the current node is being used in a different context\n   * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n   *\n   *    { undefined <- A <-> B <-> C -> undefined }\n   *                   \u2191           \u2191\n   *                   \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   * target._sources = A; (node is head)  \u2502\n   *                   \u2193                  \u2502\n   * target._sources = C; (node is tail) \u2500\u2518\n   */\n  for (\n    let node = target._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    const rollbackNode = node._source._node;\n    if (rollbackNode !== undefined) {\n      node._rollbackNode = rollbackNode;\n    }\n    node._source._node = node;\n    node._version = -1;\n\n    if (node._nextSource === undefined) {\n      target._sources = node;\n      break;\n    }\n  }\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n  let node = target._sources;\n  let head = undefined;\n\n  /**\n   * At this point 'target._sources' points to the tail of the doubly-linked list.\n   * It contains all existing sources + new sources in order of use.\n   * Iterate backwards until we find the head node while dropping old dependencies.\n   */\n  while (node !== undefined) {\n    const prev = node._prevSource;\n\n    /**\n     * The node was not re-used, unsubscribe from its change notifications and remove itself\n     * from the doubly-linked list. e.g:\n     *\n     * { A <-> B <-> C }\n     *         \u2193\n     *    { A <-> C }\n     */\n    if (node._version === -1) {\n      node._source._unsubscribe(node);\n\n      if (prev !== undefined) {\n        prev._nextSource = node._nextSource;\n      }\n      if (node._nextSource !== undefined) {\n        node._nextSource._prevSource = prev;\n      }\n    } else {\n      /**\n       * The new head is the last node seen which wasn't removed/unsubscribed\n       * from the doubly-linked list. e.g:\n       *\n       * { A <-> B <-> C }\n       *   \u2191     \u2191     \u2191\n       *   \u2502     \u2502     \u2514 head = node\n       *   \u2502     \u2514 head = node\n       *   \u2514 head = node\n       */\n      head = node;\n    }\n\n    node._source._node = node._rollbackNode;\n    if (node._rollbackNode !== undefined) {\n      node._rollbackNode = undefined;\n    }\n\n    node = prev;\n  }\n\n  target._sources = head;\n}\n\ndeclare class Computed<T = any> extends Signal<T> {\n  _fn: () => T;\n  _sources?: Node;\n  _globalVersion: number;\n  _flags: number;\n\n  constructor(fn: () => T);\n\n  _notify(): void;\n  get value(): T;\n}\n\nfunction Computed(this: Computed, fn: () => unknown) {\n  Signal.call(this, undefined);\n\n  this._fn = fn;\n  this._sources = undefined;\n  this._globalVersion = globalVersion - 1;\n  this._flags = OUTDATED;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n  this._flags &= ~NOTIFIED;\n\n  if (this._flags & RUNNING) {\n    return false;\n  }\n\n  // If this computed signal has subscribed to updates from its dependencies\n  // (TRACKING flag set) and none of them have notified about changes (OUTDATED\n  // flag not set), then the computed value can't have changed.\n  if ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n    return true;\n  }\n  this._flags &= ~OUTDATED;\n\n  if (this._globalVersion === globalVersion) {\n    return true;\n  }\n  this._globalVersion = globalVersion;\n\n  // Mark this computed signal running before checking the dependencies for value\n  // changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n  this._flags |= RUNNING;\n  if (this._version > 0 && !needsToRecompute(this)) {\n    this._flags &= ~RUNNING;\n    return true;\n  }\n\n  const prevContext = evalContext;\n  try {\n    prepareSources(this);\n    evalContext = this;\n    const value = this._fn();\n    if (\n      this._flags & HAS_ERROR ||\n      this._value !== value ||\n      this._version === 0\n    ) {\n      this._value = value;\n      this._flags &= ~HAS_ERROR;\n      this._version++;\n    }\n  } catch (err) {\n    this._value = err;\n    this._flags |= HAS_ERROR;\n    this._version++;\n  }\n  evalContext = prevContext;\n  cleanupSources(this);\n  this._flags &= ~RUNNING;\n  return true;\n};\n\nComputed.prototype._subscribe = function (node) {\n  if (this._targets === undefined) {\n    this._flags |= OUTDATED | TRACKING;\n\n    // A computed signal subscribes lazily to its dependencies when it\n    // gets its first subscriber.\n    for (\n      let node = this._sources;\n      node !== undefined;\n      node = node._nextSource\n    ) {\n      node._source._subscribe(node);\n    }\n  }\n  Signal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the computed signal has any subscribers.\n  if (this._targets !== undefined) {\n    Signal.prototype._unsubscribe.call(this, node);\n\n    // Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n    // This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n    if (this._targets === undefined) {\n      this._flags &= ~TRACKING;\n\n      for (\n        let node = this._sources;\n        node !== undefined;\n        node = node._nextSource\n      ) {\n        node._source._unsubscribe(node);\n      }\n    }\n  }\n};\n\nComputed.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= OUTDATED | NOTIFIED;\n\n    for (\n      let node = this._targets;\n      node !== undefined;\n      node = node._nextTarget\n    ) {\n      node._target._notify();\n    }\n  }\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n  get(this: Computed) {\n    if (this._flags & RUNNING) {\n      throw new Error(\"Cycle detected\");\n    }\n    const node = addDependency(this);\n    this._refresh();\n    if (node !== undefined) {\n      node._version = this._version;\n    }\n    if (this._flags & HAS_ERROR) {\n      throw this._value;\n    }\n    return this._value;\n  },\n});\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n  readonly value: T;\n  peek(): T;\n\n  subscribe(fn: (value: T) => void): () => void;\n  valueOf(): T;\n  toString(): string;\n  toJSON(): T;\n  brand: typeof BRAND_SYMBOL;\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(fn: () => T): ReadonlySignal<T> {\n  return new Computed(fn);\n}\n\nfunction cleanupEffect(effect: Effect) {\n  const cleanup = effect._cleanup;\n  effect._cleanup = undefined;\n\n  if (typeof cleanup === \"function\") {\n    /*@__INLINE__**/ startBatch();\n\n    // Run cleanup functions always outside of any context.\n    const prevContext = evalContext;\n    evalContext = undefined;\n    try {\n      cleanup();\n    } catch (err) {\n      effect._flags &= ~RUNNING;\n      effect._flags |= DISPOSED;\n      disposeEffect(effect);\n      throw err;\n    } finally {\n      evalContext = prevContext;\n      endBatch();\n    }\n  }\n}\n\nfunction disposeEffect(effect: Effect) {\n  for (\n    let node = effect._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    node._source._unsubscribe(node);\n  }\n  effect._fn = undefined;\n  effect._sources = undefined;\n\n  cleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n  if (evalContext !== this) {\n    throw new Error(\"Out-of-order effect\");\n  }\n  cleanupSources(this);\n  evalContext = prevContext;\n\n  this._flags &= ~RUNNING;\n  if (this._flags & DISPOSED) {\n    disposeEffect(this);\n  }\n  endBatch();\n}\n\ntype EffectFn = () => void | (() => void);\n\ndeclare class Effect {\n  _fn?: EffectFn;\n  _cleanup?: () => void;\n  _sources?: Node;\n  _nextBatchedEffect?: Effect;\n  _flags: number;\n\n  constructor(fn: EffectFn);\n\n  _callback(): void;\n  _start(): () => void;\n  _notify(): void;\n  _dispose(): void;\n}\n\nfunction Effect(this: Effect, fn: EffectFn) {\n  this._fn = fn;\n  this._cleanup = undefined;\n  this._sources = undefined;\n  this._nextBatchedEffect = undefined;\n  this._flags = TRACKING;\n}\n\nEffect.prototype._callback = function () {\n  const finish = this._start();\n  try {\n    if (this._flags & DISPOSED) return;\n    if (this._fn === undefined) return;\n\n    const cleanup = this._fn();\n    if (typeof cleanup === \"function\") {\n      this._cleanup = cleanup;\n    }\n  } finally {\n    finish();\n  }\n};\n\nEffect.prototype._start = function () {\n  if (this._flags & RUNNING) {\n    throw new Error(\"Cycle detected\");\n  }\n  this._flags |= RUNNING;\n  this._flags &= ~DISPOSED;\n  cleanupEffect(this);\n  prepareSources(this);\n\n  /*@__INLINE__**/ startBatch();\n  const prevContext = evalContext;\n  evalContext = this;\n  return endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= NOTIFIED;\n    this._nextBatchedEffect = batchedEffect;\n    batchedEffect = this;\n  }\n};\n\nEffect.prototype._dispose = function () {\n  this._flags |= DISPOSED;\n\n  if (!(this._flags & RUNNING)) {\n    disposeEffect(this);\n  }\n};\n\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn): () => void {\n  const effect = new Effect(fn);\n  try {\n    effect._callback();\n  } catch (err) {\n    effect._dispose();\n    throw err;\n  }\n  // Return a bound function instead of a wrapper like `() => effect._dispose()`,\n  // because bound functions seem to be just as fast and take up a lot less memory.\n  return effect._dispose.bind(effect);\n}\n\nexport { batch, computed, effect, Signal, untracked };\nexport type { ReadonlySignal };\n", "// From https://github.com/EthanStandel/deepsignal/blob/main/packages/core/src/core.ts\nimport { Signal, batch, signal } from './preact-core'\n\nexport type AtomicState =\n  | Array<unknown>\n  | ((...args: unknown[]) => unknown)\n  | string\n  | boolean\n  | number\n  | bigint\n  | symbol\n  | undefined\n  | null\n\nexport type DeepState = {\n  [key: string]: (() => unknown) | AtomicState | DeepState\n}\n\nexport type ReadOnlyDeep<T> = {\n  readonly [P in keyof T]: ReadOnlyDeep<T[P]>\n}\n\nexport interface DeepSignalAccessors<T extends DeepState> {\n  value: ReadOnlyDeep<T>\n  peek: () => ReadOnlyDeep<T>\n}\n\nexport type DeepSignalType<T extends DeepState> = DeepSignalAccessors<T> & {\n  [K in keyof T]: T[K] extends AtomicState ? Signal<T[K]> : T[K] extends DeepState ? DeepSignalType<T[K]> : Signal<T[K]>\n}\n\nexport class DeepSignal<T extends DeepState> implements DeepSignalAccessors<T> {\n  get value(): ReadOnlyDeep<T> {\n    return getValue(this as DeepSignalType<T>)\n  }\n\n  set value(payload: ReadOnlyDeep<T>) {\n    batch(() => setValue(this as DeepSignalType<T>, payload))\n  }\n\n  peek(): ReadOnlyDeep<T> {\n    return getValue(this as DeepSignalType<T>, { peek: true })\n  }\n}\n\nexport const deepSignal = <T extends DeepState>(initialValue: T): DeepSignalType<T> =>\n  Object.assign(\n    new DeepSignal(),\n    Object.entries(initialValue).reduce(\n      (acc, [key, value]) => {\n        if (['value', 'peek'].some((iKey) => iKey === key)) {\n          throw new Error(`${key} is a reserved property name`)\n        } else if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n          acc[key] = signal(value)\n        } else {\n          acc[key] = deepSignal(value)\n        }\n        return acc\n      },\n      {} as { [key: string]: unknown },\n    ),\n  ) as DeepSignalType<T>\n\nconst setValue = <U extends DeepState, T extends DeepSignalType<U>>(deepSignal: T, payload: U): void =>\n  Object.keys(payload).forEach((key: keyof U) => (deepSignal[key].value = payload[key]))\n\nconst getValue = <U extends DeepState, T extends DeepSignalType<U>>(\n  deepSignal: T,\n  { peek = false }: { peek?: boolean } = {},\n): ReadOnlyDeep<U> =>\n  Object.entries(deepSignal).reduce(\n    (acc, [key, value]) => {\n      if (value instanceof Signal) {\n        acc[key] = peek ? value.peek() : value.value\n      } else if (value instanceof DeepSignal) {\n        acc[key] = getValue(value as DeepSignalType<DeepState>, { peek })\n      }\n      return acc\n    },\n    {} as { [key: string]: unknown },\n  ) as ReadOnlyDeep<U>\n", "// From https://github.com/riagominota/ts-merge-patch/blob/main/src/index.ts\n\ntype mpObj<T> = { [k in keyof T | string | number | symbol]: any };\nexport function apply<L, R>(\n  target: mpObj<L>,\n  patchItem: mpObj<R>,\n): Partial<L> & Partial<R>;\nexport function apply<L, R>(target: mpObj<L>, patchItem: mpObj<R>): R;\nexport function apply<L, R>(target: mpObj<L>, patchItem: mpObj<R>): {};\nexport function apply<L, R>(target: mpObj<L>, patchItem: null): null;\nexport function apply<L, R>(target: mpObj<L>, patchItem: string): string;\nexport function apply<L, R>(target: mpObj<L>, patchItem: number): number;\nexport function apply<L, R>(target: mpObj<L>, patchItem: undefined): undefined;\nexport function apply<L, R>(target: mpObj<L>, patchItem: R[]): R[];\n\nexport function apply(target: any, patchItem: any): any {\n  /**\n   * If the patch is anything other than an object,\n   * the result will always be to replace\n   * the entire target with the entire patch.\n   */\n  if (typeof patchItem !== \"object\" || Array.isArray(patchItem) || !patchItem) {\n    return JSON.parse(JSON.stringify(patchItem)); //return new instance of variable\n  }\n\n  if (\n    typeof patchItem === \"object\" &&\n    patchItem.toJSON !== undefined &&\n    typeof patchItem.toJSON === \"function\"\n  ) {\n    return patchItem.toJSON();\n  }\n  /** Also, it is not possible to\n   * patch part of a target that is not an object,\n   * such as to replace just some of the values in an array.\n   */\n  let targetResult = target;\n  if (typeof target !== \"object\") {\n    //Target is empty/not an object, so basically becomes patch, minus any null valued sections (becomes {} + patch)\n    targetResult = { ...patchItem };\n  }\n\n  Object.keys(patchItem).forEach((k) => {\n    if (!targetResult.hasOwnProperty(k)) targetResult[k] = patchItem[k]; //This ensure the key exists and TS can't throw a wobbly over an undefined key\n    if (patchItem[k] === null) {\n      delete targetResult[k];\n    } else {\n      targetResult[k] = apply(targetResult[k], patchItem[k]);\n    }\n  });\n  return targetResult;\n}\n", "export const VERSION = '0.20.0';\n", "import { nodeHTMLorSVGElement } from \"../utils/dom\";\nimport { HTMLorSVGElement } from \"../utils/types\";\nimport { DeepSignal, deepSignal, DeepState } from \"../vendored/deepsignal\";\nimport { computed, effect, Signal, signal } from \"../vendored/preact-core\";\nimport { apply } from \"../vendored/ts-merge-patch\";\nimport {\n    PLUGIN_ACTION,\n    PLUGIN_ATTRIBUTE,\n    PLUGIN_PREPROCESSOR,\n    PLUGIN_WATCHER,\n} from \"./client_only_consts\";\nimport {\n    ActionPlugin,\n    ActionPlugins,\n    AttribtueExpressionFunction,\n    AttributeContext,\n    AttributePlugin,\n    DatastarPlugin,\n    InitContext,\n    OnRemovalFn,\n    PreprocessorPlugin,\n    Reactivity,\n    WatcherPlugin,\n} from \"./types\";\nimport { VERSION } from \"./version\";\n\nconst isPreprocessorPlugin = (p: DatastarPlugin): p is PreprocessorPlugin =>\n    p.pluginType === PLUGIN_PREPROCESSOR;\nconst isWatcherPlugin = (p: DatastarPlugin): p is WatcherPlugin =>\n    p.pluginType === PLUGIN_WATCHER;\nconst isAttributePlugin = (p: DatastarPlugin): p is AttributePlugin =>\n    p.pluginType === PLUGIN_ATTRIBUTE;\nconst isActionPlugin = (p: DatastarPlugin): p is ActionPlugin =>\n    p.pluginType === PLUGIN_ACTION;\n\nconst alreadyExistsErr = (type: string, name: string) =>\n    new Error(`A ${type} named '${name}' already exists`);\nexport class Engine {\n    plugins: AttributePlugin[] = [];\n    store: DeepSignal<any> = deepSignal({ _dsPlugins: {} });\n    preprocessors = new Array<PreprocessorPlugin>();\n    actions: ActionPlugins = {};\n    watchers = new Array<WatcherPlugin>();\n    refs: Record<string, HTMLElement> = {};\n    reactivity: Reactivity = {\n        signal,\n        computed,\n        effect,\n    };\n    parentID = \"\";\n    missingIDNext = 0;\n    removals = new Map<Element, { id: string; set: Set<OnRemovalFn> }>();\n    mergeRemovals = new Array<OnRemovalFn>();\n\n    constructor() {\n        // const observer = new MutationObserver(\n        //     (_mutationList, _observer) => {\n        //         this.sendDatastarEvent(\n        //             \"core\",\n        //             \"dom\",\n        //             \"mutation\",\n        //             document.body,\n        //             document.body.outerHTML,\n        //         );\n        //     },\n        // );\n\n        // Start observing the target node for configured mutations\n        // observer.observe(document.body, {\n        //     attributes: true,\n        //     childList: true,\n        //     subtree: true,\n        // });\n    }\n\n    get version() {\n        return VERSION;\n    }\n\n    load(...pluginsToLoad: DatastarPlugin[]) {\n        const allLoadedPlugins = new Set<DatastarPlugin>(this.plugins);\n\n        pluginsToLoad.forEach((plugin) => {\n            if (plugin.requiredPlugins) {\n                for (\n                    const requiredPluginType of plugin\n                        .requiredPlugins\n                ) {\n                    if (\n                        !allLoadedPlugins.has(requiredPluginType)\n                    ) {\n                        throw new Error(\n                            `Plugin '${plugin.name}' requires plugin '${requiredPluginType}' to be loaded`,\n                        );\n                    }\n                }\n            }\n\n            let globalInitializer: ((ctx: InitContext) => void) | undefined;\n            if (isPreprocessorPlugin(plugin)) {\n                if (this.preprocessors.includes(plugin)) {\n                    throw alreadyExistsErr(\"Preprocessor\", plugin.name);\n                }\n                this.preprocessors.push(plugin);\n            } else if (isWatcherPlugin(plugin)) {\n                if (this.watchers.includes(plugin)) {\n                    throw alreadyExistsErr(\"Watcher\", plugin.name);\n                }\n                this.watchers.push(plugin);\n                globalInitializer = plugin.onGlobalInit;\n            } else if (isActionPlugin(plugin)) {\n                if (!!this.actions[plugin.name]) {\n                    throw alreadyExistsErr(\"Action\", plugin.name);\n                }\n                this.actions[plugin.name] = plugin;\n            } else if (isAttributePlugin(plugin)) {\n                if (this.plugins.includes(plugin)) {\n                    throw alreadyExistsErr(\"Attribute\", plugin.name);\n                }\n                this.plugins.push(plugin);\n                globalInitializer = plugin.onGlobalInit;\n            } else {\n                throw new Error(`Unknown plugin type: ${plugin}`);\n            }\n\n            if (globalInitializer) {\n                globalInitializer({\n                    store: this.store,\n                    upsertIfMissingFromStore: this.upsertIfMissingFromStore\n                        .bind(this),\n                    mergeStore: this.mergeStore.bind(this),\n                    removeFromStore: this.removeFromStore.bind(this),\n                    actions: this.actions,\n                    reactivity: this.reactivity,\n                    applyPlugins: this.applyPlugins.bind(this),\n                    cleanupElementRemovals: this.cleanupElementRemovals.bind(\n                        this,\n                    ),\n                    // sendDatastarEvent: this.sendDatastarEvent.bind(this),\n                });\n            }\n\n            // this.sendDatastarEvent(\n            //     \"core\",\n            //     \"plugins\",\n            //     \"registration\",\n            //     \"BODY\",\n            //     `On prefix ${plugin.name}`,\n            // );\n\n            allLoadedPlugins.add(plugin);\n        });\n\n        this.applyPlugins(document.body);\n    }\n\n    // private sendDatastarEvent(\n    //     category: \"core\" | \"plugin\",\n    //     subcategory: string,\n    //     type: string,\n    //     target: Element | Document | Window | string,\n    //     message: string,\n    //     opts: CustomEventInit = {\n    //         bubbles: true,\n    //         cancelable: true,\n    //         composed: true,\n    //     },\n    // ) {\n    //     const contents = Object.assign(\n    //         {\n    //             detail: {\n    //                 time: new Date(),\n    //                 category,\n    //                 subcategory,\n    //                 type,\n    //                 target: elemToSelector(target),\n    //                 message,\n    //             },\n    //         },\n    //         opts,\n    //     );\n    //     const evt = new CustomEvent<DatastarEvent>(DATASTAR_EVENT, contents);\n    //     // console.log(\"Sending Datastar event\", evt);\n    //     window.dispatchEvent(evt);\n    // }\n\n    private cleanupElementRemovals(element: Element) {\n        const removalSet = this.removals.get(element);\n        if (removalSet) {\n            for (const removal of removalSet.set) {\n                removal();\n            }\n            this.removals.delete(element);\n        }\n    }\n\n    lastMarshalledStore = \"\";\n    private mergeStore<T extends object>(mergeStore: T) {\n        this.mergeRemovals.forEach((removal) => removal());\n        this.mergeRemovals = this.mergeRemovals.slice(0);\n\n        const revisedStore = apply(this.store.value, mergeStore) as DeepState;\n        this.store = deepSignal(revisedStore);\n\n        const marshalledStore = JSON.stringify(this.store.value);\n        if (marshalledStore === this.lastMarshalledStore) return;\n\n        // this.sendDatastarEvent(\n        //     \"core\",\n        //     \"store\",\n        //     \"merged\",\n        //     \"STORE\",\n        //     marshalledStore,\n        // );\n    }\n\n    private removeFromStore(...keys: string[]) {\n        const revisedStore = { ...this.store.value };\n        for (const key of keys) {\n            const parts = key.split(\".\");\n            let currentID = parts[0];\n            let subStore = revisedStore;\n            for (let i = 1; i < parts.length; i++) {\n                const part = parts[i];\n                if (!subStore[currentID]) {\n                    subStore[currentID] = {};\n                }\n                subStore = subStore[currentID];\n                currentID = part;\n            }\n            delete subStore[currentID];\n        }\n        this.store = deepSignal(revisedStore);\n        this.applyPlugins(document.body);\n    }\n\n    private upsertIfMissingFromStore(path: string, value: any) {\n        const parts = path.split(\".\");\n        let subStore = this.store as any;\n        for (let i = 0; i < parts.length - 1; i++) {\n            const part = parts[i];\n            if (!subStore[part]) {\n                subStore[part] = {};\n            }\n            subStore = subStore[part];\n        }\n        const last = parts[parts.length - 1];\n        if (!!subStore[last]) return;\n        subStore[last] = this.reactivity.signal(value);\n        // this.sendDatastarEvent(\"core\", \"store\", \"upsert\", path, value);\n    }\n\n    signalByName<T>(name: string) {\n        return (this.store as any)[name] as Signal<T>;\n    }\n\n    private applyPlugins(rootElement: Element) {\n        const appliedProcessors = new Set<PreprocessorPlugin>();\n\n        this.plugins.forEach((p, pi) => {\n            this.walkDownDOM(rootElement, (el) => {\n                if (!pi) this.cleanupElementRemovals(el);\n\n                for (const rawKey in el.dataset) {\n                    const rawExpression = `${el.dataset[rawKey]}` || \"\";\n                    let expression = rawExpression;\n\n                    if (!rawKey.startsWith(p.name)) continue;\n\n                    if (el.id.length === 0) {\n                        el.id = `ds-${this.parentID}-${this.missingIDNext++}`;\n                    }\n\n                    appliedProcessors.clear();\n\n                    if (p.allowedTagRegexps) {\n                        const lowerCaseTag = el.tagName.toLowerCase();\n                        const allowed = [...p.allowedTagRegexps].some((r) =>\n                            lowerCaseTag.match(r)\n                        );\n                        if (!allowed) {\n                            throw new Error(\n                                `'${el.tagName}' not allowed for '${rawKey}', allowed ${\n                                    [\n                                        [...p.allowedTagRegexps].map((t) =>\n                                            `'${t}'`\n                                        ),\n                                    ].join(\", \")\n                                }`,\n                            );\n                        }\n                    }\n\n                    let keyRaw = rawKey.slice(p.name.length);\n                    let [key, ...modifiersWithArgsArr] = keyRaw.split(\".\");\n                    if (p.mustHaveEmptyKey && key.length > 0) {\n                        throw new Error(`'${rawKey}' must have empty key`);\n                    }\n                    if (p.mustNotEmptyKey && key.length === 0) {\n                        throw new Error(`'${rawKey}' must have non-empty key`);\n                    }\n                    if (key.length) {\n                        key = key[0].toLowerCase() + key.slice(1);\n                    }\n\n                    const modifiersArr = modifiersWithArgsArr.map((m) => {\n                        const [label, ...args] = m.split(\"_\");\n                        return { label, args };\n                    });\n                    if (p.allowedModifiers) {\n                        for (const modifier of modifiersArr) {\n                            if (!p.allowedModifiers.has(modifier.label)) {\n                                throw new Error(\n                                    `'${modifier.label}' is not allowed`,\n                                );\n                            }\n                        }\n                    }\n                    const modifiers = new Map<string, string[]>();\n                    for (const modifier of modifiersArr) {\n                        modifiers.set(modifier.label, modifier.args);\n                    }\n\n                    if (p.mustHaveEmptyExpression && expression.length) {\n                        throw new Error(\n                            `'${rawKey}' must have empty expression`,\n                        );\n                    }\n                    if (p.mustNotEmptyExpression && !expression.length) {\n                        throw new Error(\n                            `'${rawKey}' must have non-empty expression`,\n                        );\n                    }\n\n                    const splitRegex = /;|\\n/;\n\n                    if (p.removeNewLines) {\n                        expression = expression\n                            .split(\"\\n\")\n                            .map((p: string) => p.trim())\n                            .join(\" \");\n                    }\n\n                    const processors = [\n                        ...(p.preprocessors?.pre || []),\n                        ...this.preprocessors,\n                        ...(p.preprocessors?.post || []),\n                    ];\n                    for (const processor of processors) {\n                        if (appliedProcessors.has(processor)) continue;\n                        appliedProcessors.add(processor);\n\n                        const expressionParts = expression.split(splitRegex);\n                        const revisedParts: string[] = [];\n\n                        expressionParts.forEach((exp) => {\n                            let revised = exp;\n                            const matches = [\n                                ...revised.matchAll(processor.regexp),\n                            ];\n                            if (matches.length) {\n                                for (const match of matches) {\n                                    if (!match.groups) continue;\n                                    const { groups } = match;\n                                    const { whole } = groups;\n                                    revised = revised.replace(\n                                        whole,\n                                        processor.replacer(groups),\n                                    );\n                                }\n                            }\n                            revisedParts.push(revised);\n                        });\n                        // })\n\n                        expression = revisedParts.join(\"; \");\n                    }\n\n                    const ctx: AttributeContext = {\n                        store: () => this.store,\n                        mergeStore: this.mergeStore.bind(this),\n                        upsertIfMissingFromStore: this.upsertIfMissingFromStore\n                            .bind(this),\n                        removeFromStore: this.removeFromStore.bind(this),\n                        applyPlugins: this.applyPlugins.bind(this),\n                        cleanupElementRemovals: this.cleanupElementRemovals\n                            .bind(this),\n                        walkSignals: this.walkSignals.bind(this),\n                        actions: this.actions,\n                        reactivity: this.reactivity,\n                        el,\n                        rawKey,\n                        key,\n                        rawExpression,\n                        expression,\n                        expressionFn: () => {\n                            throw new Error(\"Expression function not created\");\n                        },\n                        modifiers,\n                        // sendDatastarEvent: this.sendDatastarEvent.bind(this),\n                    };\n\n                    if (\n                        !p.bypassExpressionFunctionCreation?.(ctx) &&\n                        !p.mustHaveEmptyExpression && expression.length\n                    ) {\n                        const statements = expression\n                            .split(splitRegex)\n                            .map((s) => s.trim())\n                            .filter((s) => s.length);\n                        statements[statements.length - 1] = `return ${\n                            statements[statements.length - 1]\n                        }`;\n                        const joined = statements.map((s) => `  ${s}`).join(\n                            \";\\n\",\n                        );\n                        const fnContent = `\n  try {\n    const _datastarExpression = () => {\n  ${joined}\n    }\n    const _datastarReturnVal = _datastarExpression()\n    ctx.sendDatastarEvent('core', 'attributes', 'expr_eval', ctx.el, '${rawKey} equals ' + JSON.stringify(_datastarReturnVal))\n    return _datastarReturnVal\n  } catch (e) {\n   const msg = \\`\n  Error evaluating Datastar expression:\n  ${joined.replaceAll(\"`\", \"\\\\`\")}\n\n  Error: \\${e.message}\n\n  Check if the expression is valid before raising an issue.\n  \\`.trim()\n   ctx.sendDatastarEvent('core', 'attributes', 'expr_eval_err', ctx.el, msg)\n   console.error(msg)\n   debugger\n  }\n              `;\n\n                        /*sendDatastarEvent(\n                'core',\n                'attributes',\n                'expr_construction',\n                ctx.el,\n                `${rawKey}=\"${rawExpression}\" becomes: ${joined}`,\n              )*/\n                        try {\n                            const argumentNames = p.argumentNames || [];\n                            const fn = new Function(\n                                \"ctx\",\n                                ...argumentNames,\n                                fnContent,\n                            ) as AttribtueExpressionFunction;\n                            ctx.expressionFn = fn;\n                        } catch (e) {\n                            const err = new Error(\n                                `Error creating expression function for '${fnContent}', error: ${e}`,\n                            );\n                            // this.sendDatastarEvent(\n                            //     \"core\",\n                            //     \"attributes\",\n                            //     \"expr_construction_err\",\n                            //     ctx.el,\n                            //     String(err),\n                            // );\n                            console.error(err);\n                            debugger;\n                        }\n                    }\n\n                    const removal = p.onLoad(ctx);\n                    if (removal) {\n                        if (!this.removals.has(el)) {\n                            this.removals.set(el, {\n                                id: el.id,\n                                set: new Set(),\n                            });\n                        }\n                        this.removals.get(el)!.set.add(removal);\n                    }\n                }\n            });\n        });\n    }\n\n    private walkSignalsStore(\n        store: any,\n        callback: (name: string, signal: Signal<any>) => void,\n    ) {\n        const keys = Object.keys(store);\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            const value = store[key];\n            const isSignal = value instanceof Signal;\n            const hasChildren = typeof value === \"object\" &&\n                Object.keys(value).length > 0;\n\n            if (isSignal) {\n                callback(key, value);\n                continue;\n            }\n\n            if (!hasChildren) continue;\n\n            this.walkSignalsStore(value, callback);\n        }\n    }\n\n    private walkSignals(callback: (name: string, signal: Signal<any>) => void) {\n        this.walkSignalsStore(this.store, callback);\n    }\n\n    private walkDownDOM(\n        element: Element | null,\n        callback: (el: HTMLorSVGElement) => void,\n        siblingOffset = 0,\n    ) {\n        if (!element) return;\n        const el = nodeHTMLorSVGElement(element);\n        if (!el) return;\n\n        callback(el);\n\n        siblingOffset = 0;\n        element = element.firstElementChild;\n        while (element) {\n            this.walkDownDOM(element, callback, siblingOffset++);\n            element = element.nextElementSibling;\n        }\n    }\n}\n", "// This is auto-generated by Datastar. DO NOT EDIT.\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_EVENT = \"datastar-event\";\nexport const DATASTAR_REQUEST = \"datastar-request\";\nexport const VERSION = \"0.20.0\";\n\n// Defaults\n\n// Default durations\nexport const DefaultSettleDurationMs = 300;\nexport const DefaultSseRetryDurationMs = 1000;\n\n// Default strings\nexport const DefaultExecuteJsType = \"module\";\nexport const DefaultCustomEventSelector = \"document\";\nexport const DefaultCustomEventDetailJson = \"{}\";\n\n// Default booleans\nexport const DefaultMergeFragmentsUseViewTransitions = false;\nexport const DefaultMergeStoreOnlyIfMissing = false;\nexport const DefaultExecuteJsAutoRemove = true;\nexport const DefaultCustomEventCancelable = true;\nexport const DefaultCustomEventComposed = true;\nexport const DefaultCustomEventBubbles = true;\n\nexport const FragmentMergeModes = {\n    Morph: \"morph\", // Morphs the fragment into the existing element using idiomorph.\n    Inner: \"inner\", // Replaces the inner HTML of the existing element.\n    Outer: \"outer\", // Replaces the outer HTML of the existing element.\n    Prepend: \"prepend\", // Prepends the fragment to the existing element.\n    Append: \"append\", // Appends the fragment to the existing element.\n    Before: \"before\", // Inserts the fragment before the existing element.\n    After: \"after\", // Inserts the fragment after the existing element.\n    UpsertAttributes: \"upsertAttributes\", // Upserts the attributes of the existing element.\n} as const;\n\n// Default value for FragmentMergeMode\nexport const DefaultFragmentMergeMode = FragmentMergeModes.Morph;\n\nexport const EventTypes = {\n    MergeFragments: \"datastar-merge-fragments\", // An event dealing with HTML fragments.\n    MergeStore: \"datastar-merge-store\", // An event dealing with fine grain signals.\n    RemoveFragments: \"datastar-remove-fragments\", // An event dealing with removing elements from the DOM\n    RemoveFromStore: \"datastar-remove-from-store\", // An event dealing with removing signals from the store.\n    ExecuteJs: \"datastar-execute-js\", // An event dealing with executing JavaScript in the browser.\n} as const;", "import { Star } from \"../plugins/official/attributes/core/advice\";\nimport { Computed } from \"../plugins/official/attributes/core/computed\";\nimport { Store } from \"../plugins/official/attributes/core/store\";\nimport { ActionsProcessor } from \"../plugins/official/preprocessors/core/actions\";\nimport { SignalsProcessor } from \"../plugins/official/preprocessors/core/signals\";\nimport { Engine } from \"./engine\";\n\nexport * from \"./consts\";\nexport type * from \"./types\";\n\nconst ds = new Engine();\nds.load(\n    ActionsProcessor,\n    SignalsProcessor,\n    Store,\n    Computed,\n    Star,\n);\n\nexport const Datastar = ds;\n", "import { Datastar } from \"../engine\";\n\nDatastar.load();\n"],
  "mappings": "mBAOO,IAAMA,EAAwB,CACjC,WAAY,YACZ,KAAM,OACN,OAAQ,IAAM,CACV,MAAM,sCAAsC,CAChD,CACJ,ECbO,IAAMC,EAAgB,SAChBC,EAAiB,UACjBC,EAAsB,eACtBC,EAAmB,YCKzB,IAAMC,GAA4B,CACrC,WAAYC,EACZ,KAAM,WACN,gBAAiB,GACjB,OAASC,GAAQ,CACb,IAAMC,EAAQD,EAAI,MAAM,EACxB,OAAAC,EAAMD,EAAI,GAAG,EAAIA,EAAI,WAAW,SAAS,IAC9BA,EAAI,aAAaA,CAAG,CAC9B,EAEM,IAAM,CACT,IAAMC,EAAQD,EAAI,MAAM,EACxB,OAAOC,EAAMD,EAAI,GAAG,CACxB,CACJ,CACJ,ECPO,SAASE,GACZC,EACAC,EACAC,EACF,CACE,IAAMC,EAAc,CAAC,EAErB,GAAI,CAACD,EACD,OAAO,OAAOC,EAAQF,CAAQ,MAE9B,SAAWG,KAAOH,EAAU,CACxB,IAAMI,EAAeL,EAAaI,CAAG,GAAG,MACNC,GAAiB,OAC/CF,EAAOC,CAAG,EAAIH,EAASG,CAAG,EAElC,CAGJ,OAAOD,CACX,CClBO,IAAMG,GAAyB,CAClC,WAAYC,EACZ,KAAM,QACN,eAAgB,GAChB,cAAe,CACX,IAAK,CACD,CACI,WAAYC,EACZ,KAAM,QACN,OAAQ,gBACR,SAAWC,GAAyB,CAChC,GAAM,CAAE,MAAAC,CAAM,EAAID,EAClB,MAAO,mCAAmCC,CAAK,GACnD,CACJ,CACJ,CACJ,EACA,iBAAkB,IAAI,IAAI,CAAC,WAAW,CAAC,EACvC,OAASC,GAA0B,CAC/B,IAAMC,EAAqBD,EAAI,aAAaA,CAAG,EACzCE,EAAmBC,GACrBH,EAAI,MAAM,EACVC,EACAD,EAAI,UAAU,IAAI,WAAW,CACjC,EACAA,EAAI,WAAWE,CAAgB,EAE/B,OAAOF,EAAI,GAAG,QAAQA,EAAI,MAAM,CACpC,CACJ,EC9CO,IAAMI,GAAoB,cACpBC,GAA0BD,GAAoB,kBAEpD,SAASE,EACZC,EACAC,EACAC,EACAC,EAAW,GACb,CACE,IAAMC,EAAaD,EAAWL,GAA0BD,GACxD,OAAO,IAAI,OACP,YAAYG,CAAI,MAAMC,CAAM,IAAIG,CAAU,IAAIF,CAAM,IACpD,GACJ,CACJ,CCTO,IAAMG,GAAuC,CAChD,KAAM,SACN,WAAYC,EACZ,OAAQC,EACJ,MACA,SACA,6BACA,EACJ,EACA,SAAU,CAAC,CAAE,OAAAC,EAAQ,KAAAC,CAAK,IAAoB,CAC1C,IAAMC,EAAU,CAAC,KAAK,EAClBD,GACAC,EAAQ,KAAK,GAAGD,EAAK,MAAM,GAAG,EAAE,IAAKE,GAAMA,EAAE,KAAK,CAAC,CAAC,EAExD,IAAMC,EAAaF,EAAQ,KAAK,GAAG,EACnC,MAAO,eAAeF,CAAM,WAAWI,CAAU,GACrD,CACJ,ECjBO,IAAMC,GAAuC,CAChD,KAAM,SACN,WAAYC,EACZ,OAAQC,EAAkB,MAAO,SAAU,2BAA2B,EACtE,SAAWC,GAAyB,CAChC,GAAM,CAAE,OAAAC,EAAQ,OAAAC,CAAO,EAAIF,EACrBG,EAAS,cACf,GAAI,CAACD,GAAQ,OACT,MAAO,GAAGC,CAAM,IAAIF,CAAM,SAE9B,IAAMG,EAAQH,EAAO,MAAM,GAAG,EACxBI,EAAaD,EAAM,IAAI,EACvBE,EAAeF,EAAM,KAAK,GAAG,EACnC,MAAO,GAAGD,CAAM,IAAIG,CAAY,UAAUD,CAAU,GAAGH,CAAM,EACjE,CACJ,ECWO,SAASK,GAAqBC,EAAqC,CACtE,OAAMA,aAAgB,aAAeA,aAAgB,WAG9CA,EAFI,IAGf,CClCA,IAAMC,GAAe,OAAO,IAAI,gBAAgB,EAG1CC,EAAU,EACVC,EAAW,EACXC,EAAW,EACXC,EAAW,EACXC,EAAY,GACZC,EAAW,GA0BjB,SAASC,GAAa,CACpBC,GACF,CAEA,SAASC,GAAW,CAClB,GAAID,EAAa,EAAG,CAClBA,IACA,MACF,CAEA,IAAIE,EACAC,EAAW,GAEf,KAAOC,IAAkB,QAAW,CAClC,IAAIC,EAA6BD,EAKjC,IAJAA,EAAgB,OAEhBE,IAEOD,IAAW,QAAW,CAC3B,IAAME,EAA2BF,EAAO,mBAIxC,GAHAA,EAAO,mBAAqB,OAC5BA,EAAO,QAAU,CAACX,EAEd,EAAEW,EAAO,OAAST,IAAaY,GAAiBH,CAAM,EACxD,GAAI,CACFA,EAAO,UAAU,CACnB,OAASI,EAAK,CACPN,IACHD,EAAQO,EACRN,EAAW,GAEf,CAEFE,EAASE,CACX,CACF,CAIA,GAHAD,EAAiB,EACjBN,IAEIG,EACF,MAAMD,CAEV,CAcA,SAASQ,GAASC,EAAgB,CAChC,GAAIX,EAAa,EACf,OAAOW,EAAG,EAEKZ,EAAW,EAC5B,GAAI,CACF,OAAOY,EAAG,CACZ,QAAE,CACAV,EAAS,CACX,CACF,CAGA,IAAIW,EAoBJ,IAAIC,EACAC,EAAa,EACbC,EAAiB,EAIjBC,EAAgB,EAEpB,SAASC,GAAcC,EAAkC,CACvD,GAAIC,IAAgB,OAClB,OAGF,IAAIC,EAAOF,EAAO,MAClB,GAAIE,IAAS,QAAaA,EAAK,UAAYD,EAazC,OAAAC,EAAO,CACL,SAAU,EACV,QAASF,EACT,YAAaC,EAAY,SACzB,YAAa,OACb,QAASA,EACT,YAAa,OACb,YAAa,OACb,cAAeC,CACjB,EAEID,EAAY,WAAa,SAC3BA,EAAY,SAAS,YAAcC,GAErCD,EAAY,SAAWC,EACvBF,EAAO,MAAQE,EAIXD,EAAY,OAASE,GACvBH,EAAO,WAAWE,CAAI,EAEjBA,EACF,GAAIA,EAAK,WAAa,GAE3B,OAAAA,EAAK,SAAW,EAeZA,EAAK,cAAgB,SACvBA,EAAK,YAAY,YAAcA,EAAK,YAEhCA,EAAK,cAAgB,SACvBA,EAAK,YAAY,YAAcA,EAAK,aAGtCA,EAAK,YAAcD,EAAY,SAC/BC,EAAK,YAAc,OAEnBD,EAAY,SAAU,YAAcC,EACpCD,EAAY,SAAWC,GAKlBA,CAGX,CAgEA,SAASE,EAAqBC,EAAiB,CAC7C,KAAK,OAASA,EACd,KAAK,SAAW,EAChB,KAAK,MAAQ,OACb,KAAK,SAAW,MAClB,CAEAD,EAAO,UAAU,MAAQE,GAEzBF,EAAO,UAAU,SAAW,UAAY,CACtC,MAAO,EACT,EAEAA,EAAO,UAAU,WAAa,SAAUF,EAAM,CACxC,KAAK,WAAaA,GAAQA,EAAK,cAAgB,SACjDA,EAAK,YAAc,KAAK,SACpB,KAAK,WAAa,SACpB,KAAK,SAAS,YAAcA,GAE9B,KAAK,SAAWA,EAEpB,EAEAE,EAAO,UAAU,aAAe,SAAUF,EAAM,CAE9C,GAAI,KAAK,WAAa,OAAW,CAC/B,IAAMK,EAAOL,EAAK,YACZM,EAAON,EAAK,YACdK,IAAS,SACXA,EAAK,YAAcC,EACnBN,EAAK,YAAc,QAEjBM,IAAS,SACXA,EAAK,YAAcD,EACnBL,EAAK,YAAc,QAEjBA,IAAS,KAAK,WAChB,KAAK,SAAWM,EAEpB,CACF,EAEAJ,EAAO,UAAU,UAAY,SAAUK,EAAI,CACzC,OAAOC,EAAO,IAAM,CAClB,IAAML,EAAQ,KAAK,MAEbM,EAAcV,EACpBA,EAAc,OACd,GAAI,CACFQ,EAAGJ,CAAK,CACV,QAAE,CACAJ,EAAcU,CAChB,CACF,CAAC,CACH,EAEAP,EAAO,UAAU,QAAU,UAAY,CACrC,OAAO,KAAK,KACd,EAEAA,EAAO,UAAU,SAAW,UAAY,CACtC,OAAO,KAAK,MAAQ,EACtB,EAEAA,EAAO,UAAU,OAAS,UAAY,CACpC,OAAO,KAAK,KACd,EAEAA,EAAO,UAAU,KAAO,UAAY,CAClC,IAAMO,EAAcV,EACpBA,EAAc,OACd,GAAI,CACF,OAAO,KAAK,KACd,QAAE,CACAA,EAAcU,CAChB,CACF,EAEA,OAAO,eAAeP,EAAO,UAAW,QAAS,CAC/C,KAAkB,CAChB,IAAMF,EAAOH,GAAc,IAAI,EAC/B,OAAIG,IAAS,SACXA,EAAK,SAAW,KAAK,UAEhB,KAAK,MACd,EACA,IAAkBG,EAAO,CACvB,GAAIA,IAAU,KAAK,OAAQ,CACzB,GAAIR,EAAiB,IACnB,MAAM,IAAI,MAAM,gBAAgB,EAGlC,KAAK,OAASQ,EACd,KAAK,WACLP,IAEiBc,EAAW,EAC5B,GAAI,CACF,QACMV,EAAO,KAAK,SAChBA,IAAS,OACTA,EAAOA,EAAK,YAEZA,EAAK,QAAQ,QAAQ,CAEzB,QAAE,CACAW,EAAS,CACX,CACF,CACF,CACF,CAAC,EAUM,SAASb,EAAUK,EAAsB,CAC9C,OAAO,IAAID,EAAOC,CAAK,CACzB,CAEA,SAASS,GAAiBC,EAAoC,CAI5D,QACMb,EAAOa,EAAO,SAClBb,IAAS,OACTA,EAAOA,EAAK,YAKZ,GACEA,EAAK,QAAQ,WAAaA,EAAK,UAC/B,CAACA,EAAK,QAAQ,SAAS,GACvBA,EAAK,QAAQ,WAAaA,EAAK,SAE/B,MAAO,GAKX,MAAO,EACT,CAEA,SAASc,GAAeD,EAA2B,CAajD,QACMb,EAAOa,EAAO,SAClBb,IAAS,OACTA,EAAOA,EAAK,YACZ,CACA,IAAMe,EAAef,EAAK,QAAQ,MAOlC,GANIe,IAAiB,SACnBf,EAAK,cAAgBe,GAEvBf,EAAK,QAAQ,MAAQA,EACrBA,EAAK,SAAW,GAEZA,EAAK,cAAgB,OAAW,CAClCa,EAAO,SAAWb,EAClB,KACF,CACF,CACF,CAEA,SAASgB,GAAeH,EAA2B,CACjD,IAAIb,EAAOa,EAAO,SACdI,EAOJ,KAAOjB,IAAS,QAAW,CACzB,IAAMK,EAAOL,EAAK,YAUdA,EAAK,WAAa,IACpBA,EAAK,QAAQ,aAAaA,CAAI,EAE1BK,IAAS,SACXA,EAAK,YAAcL,EAAK,aAEtBA,EAAK,cAAgB,SACvBA,EAAK,YAAY,YAAcK,IAajCY,EAAOjB,EAGTA,EAAK,QAAQ,MAAQA,EAAK,cACtBA,EAAK,gBAAkB,SACzBA,EAAK,cAAgB,QAGvBA,EAAOK,CACT,CAEAQ,EAAO,SAAWI,CACpB,CAcA,SAASC,EAAyBX,EAAmB,CACnDL,EAAO,KAAK,KAAM,MAAS,EAE3B,KAAK,IAAMK,EACX,KAAK,SAAW,OAChB,KAAK,eAAiBX,EAAgB,EACtC,KAAK,OAASuB,CAChB,CAEAD,EAAS,UAAY,IAAIhB,EAEzBgB,EAAS,UAAU,SAAW,UAAY,CAGxC,GAFA,KAAK,QAAU,CAACE,EAEZ,KAAK,OAASC,EAChB,MAAO,GAWT,IALK,KAAK,QAAUF,EAAWlB,MAAeA,IAG9C,KAAK,QAAU,CAACkB,EAEZ,KAAK,iBAAmBvB,GAC1B,MAAO,GAOT,GALA,KAAK,eAAiBA,EAItB,KAAK,QAAUyB,EACX,KAAK,SAAW,GAAK,CAACT,GAAiB,IAAI,EAC7C,YAAK,QAAU,CAACS,EACT,GAGT,IAAMZ,EAAcV,EACpB,GAAI,CACFe,GAAe,IAAI,EACnBf,EAAc,KACd,IAAMI,EAAQ,KAAK,IAAI,GAErB,KAAK,OAASmB,GACd,KAAK,SAAWnB,GAChB,KAAK,WAAa,KAElB,KAAK,OAASA,EACd,KAAK,QAAU,CAACmB,EAChB,KAAK,WAET,OAASC,EAAK,CACZ,KAAK,OAASA,EACd,KAAK,QAAUD,EACf,KAAK,UACP,CACA,OAAAvB,EAAcU,EACdO,GAAe,IAAI,EACnB,KAAK,QAAU,CAACK,EACT,EACT,EAEAH,EAAS,UAAU,WAAa,SAAUlB,EAAM,CAC9C,GAAI,KAAK,WAAa,OAAW,CAC/B,KAAK,QAAUmB,EAAWlB,EAI1B,QACMD,EAAO,KAAK,SAChBA,IAAS,OACTA,EAAOA,EAAK,YAEZA,EAAK,QAAQ,WAAWA,CAAI,CAEhC,CACAE,EAAO,UAAU,WAAW,KAAK,KAAMF,CAAI,CAC7C,EAEAkB,EAAS,UAAU,aAAe,SAAUlB,EAAM,CAEhD,GAAI,KAAK,WAAa,SACpBE,EAAO,UAAU,aAAa,KAAK,KAAMF,CAAI,EAIzC,KAAK,WAAa,QAAW,CAC/B,KAAK,QAAU,CAACC,EAEhB,QACMD,EAAO,KAAK,SAChBA,IAAS,OACTA,EAAOA,EAAK,YAEZA,EAAK,QAAQ,aAAaA,CAAI,CAElC,CAEJ,EAEAkB,EAAS,UAAU,QAAU,UAAY,CACvC,GAAI,EAAE,KAAK,OAASE,GAAW,CAC7B,KAAK,QAAUD,EAAWC,EAE1B,QACMpB,EAAO,KAAK,SAChBA,IAAS,OACTA,EAAOA,EAAK,YAEZA,EAAK,QAAQ,QAAQ,CAEzB,CACF,EAEA,OAAO,eAAekB,EAAS,UAAW,QAAS,CACjD,KAAoB,CAClB,GAAI,KAAK,OAASG,EAChB,MAAM,IAAI,MAAM,gBAAgB,EAElC,IAAMrB,EAAOH,GAAc,IAAI,EAK/B,GAJA,KAAK,SAAS,EACVG,IAAS,SACXA,EAAK,SAAW,KAAK,UAEnB,KAAK,OAASsB,EAChB,MAAM,KAAK,OAEb,OAAO,KAAK,MACd,CACF,CAAC,EAyBD,SAASE,GAAYjB,EAAgC,CACnD,OAAO,IAAIW,EAASX,CAAE,CACxB,CAEA,SAASkB,GAAcjB,EAAgB,CACrC,IAAMkB,EAAUlB,EAAO,SAGvB,GAFAA,EAAO,SAAW,OAEd,OAAOkB,GAAY,WAAY,CAChBhB,EAAW,EAG5B,IAAMD,EAAcV,EACpBA,EAAc,OACd,GAAI,CACF2B,EAAQ,CACV,OAASH,EAAK,CACZ,MAAAf,EAAO,QAAU,CAACa,EAClBb,EAAO,QAAUmB,EACjBC,EAAcpB,CAAM,EACde,CACR,QAAE,CACAxB,EAAcU,EACdE,EAAS,CACX,CACF,CACF,CAEA,SAASiB,EAAcpB,EAAgB,CACrC,QACMR,EAAOQ,EAAO,SAClBR,IAAS,OACTA,EAAOA,EAAK,YAEZA,EAAK,QAAQ,aAAaA,CAAI,EAEhCQ,EAAO,IAAM,OACbA,EAAO,SAAW,OAElBiB,GAAcjB,CAAM,CACtB,CAEA,SAASqB,GAAwBpB,EAAiC,CAChE,GAAIV,IAAgB,KAClB,MAAM,IAAI,MAAM,qBAAqB,EAEvCiB,GAAe,IAAI,EACnBjB,EAAcU,EAEd,KAAK,QAAU,CAACY,EACZ,KAAK,OAASM,GAChBC,EAAc,IAAI,EAEpBjB,EAAS,CACX,CAmBA,SAASmB,EAAqBvB,EAAc,CAC1C,KAAK,IAAMA,EACX,KAAK,SAAW,OAChB,KAAK,SAAW,OAChB,KAAK,mBAAqB,OAC1B,KAAK,OAASN,CAChB,CAEA6B,EAAO,UAAU,UAAY,UAAY,CACvC,IAAMC,EAAS,KAAK,OAAO,EAC3B,GAAI,CAEF,GADI,KAAK,OAASJ,GACd,KAAK,MAAQ,OAAW,OAE5B,IAAMD,EAAU,KAAK,IAAI,EACrB,OAAOA,GAAY,aACrB,KAAK,SAAWA,EAEpB,QAAE,CACAK,EAAO,CACT,CACF,EAEAD,EAAO,UAAU,OAAS,UAAY,CACpC,GAAI,KAAK,OAAST,EAChB,MAAM,IAAI,MAAM,gBAAgB,EAElC,KAAK,QAAUA,EACf,KAAK,QAAU,CAACM,EAChBF,GAAc,IAAI,EAClBX,GAAe,IAAI,EAEFJ,EAAW,EAC5B,IAAMD,EAAcV,EACpB,OAAAA,EAAc,KACP8B,GAAU,KAAK,KAAMpB,CAAW,CACzC,EAEAqB,EAAO,UAAU,QAAU,UAAY,CAC/B,KAAK,OAASV,IAClB,KAAK,QAAUA,EACf,KAAK,mBAAqB3B,EAC1BA,EAAgB,KAEpB,EAEAqC,EAAO,UAAU,SAAW,UAAY,CACtC,KAAK,QAAUH,EAET,KAAK,OAASN,GAClBO,EAAc,IAAI,CAEtB,EAeA,SAASpB,EAAOD,EAA0B,CACxC,IAAMC,EAAS,IAAIsB,EAAOvB,CAAE,EAC5B,GAAI,CACFC,EAAO,UAAU,CACnB,OAASe,EAAK,CACZ,MAAAf,EAAO,SAAS,EACVe,CACR,CAGA,OAAOf,EAAO,SAAS,KAAKA,CAAM,CACpC,CC/xBO,IAAMwB,EAAN,KAAwE,CAC7E,IAAI,OAAyB,CAC3B,OAAOC,EAAS,IAAyB,CAC3C,CAEA,IAAI,MAAMC,EAA0B,CAClCC,GAAM,IAAMC,GAAS,KAA2BF,CAAO,CAAC,CAC1D,CAEA,MAAwB,CACtB,OAAOD,EAAS,KAA2B,CAAE,KAAM,EAAK,CAAC,CAC3D,CACF,EAEaI,EAAmCC,GAC9C,OAAO,OACL,IAAIN,EACJ,OAAO,QAAQM,CAAY,EAAE,OAC3B,CAACC,EAAK,CAACC,EAAKC,CAAK,IAAM,CACrB,GAAI,CAAC,QAAS,MAAM,EAAE,KAAMC,GAASA,IAASF,CAAG,EAC/C,MAAM,IAAI,MAAM,GAAGA,CAAG,8BAA8B,EAC/C,OAAI,OAAOC,GAAU,UAAYA,IAAU,MAAQ,MAAM,QAAQA,CAAK,EAC3EF,EAAIC,CAAG,EAAIG,EAAOF,CAAK,EAEvBF,EAAIC,CAAG,EAAIH,EAAWI,CAAK,EAEtBF,CACT,EACA,CAAC,CACH,CACF,EAEIH,GAAW,CAAmDC,EAAeH,IACjF,OAAO,KAAKA,CAAO,EAAE,QAASM,GAAkBH,EAAWG,CAAG,EAAE,MAAQN,EAAQM,CAAG,CAAE,EAEjFP,EAAW,CACfI,EACA,CAAE,KAAAO,EAAO,EAAM,EAAwB,CAAC,IAExC,OAAO,QAAQP,CAAU,EAAE,OACzB,CAACE,EAAK,CAACC,EAAKC,CAAK,KACXA,aAAiBI,EACnBN,EAAIC,CAAG,EAAII,EAAOH,EAAM,KAAK,EAAIA,EAAM,MAC9BA,aAAiBT,IAC1BO,EAAIC,CAAG,EAAIP,EAASQ,EAAoC,CAAE,KAAAG,CAAK,CAAC,GAE3DL,GAET,CAAC,CACH,ECjEK,SAASO,EAAMC,EAAaC,EAAqB,CAMtD,GAAI,OAAOA,GAAc,UAAY,MAAM,QAAQA,CAAS,GAAK,CAACA,EAChE,OAAO,KAAK,MAAM,KAAK,UAAUA,CAAS,CAAC,EAG7C,GACE,OAAOA,GAAc,UACrBA,EAAU,SAAW,QACrB,OAAOA,EAAU,QAAW,WAE5B,OAAOA,EAAU,OAAO,EAM1B,IAAIC,EAAeF,EACnB,OAAI,OAAOA,GAAW,WAEpBE,EAAe,CAAE,GAAGD,CAAU,GAGhC,OAAO,KAAKA,CAAS,EAAE,QAASE,GAAM,CAC/BD,EAAa,eAAeC,CAAC,IAAGD,EAAaC,CAAC,EAAIF,EAAUE,CAAC,GAC9DF,EAAUE,CAAC,IAAM,KACnB,OAAOD,EAAaC,CAAC,EAErBD,EAAaC,CAAC,EAAIJ,EAAMG,EAAaC,CAAC,EAAGF,EAAUE,CAAC,CAAC,CAEzD,CAAC,EACMD,CACT,CCnDO,IAAME,GAAU,SC0BvB,IAAMC,GAAwBC,GAC1BA,EAAE,aAAeC,EACfC,GAAmBF,GACrBA,EAAE,aAAeG,EACfC,GAAqBJ,GACvBA,EAAE,aAAeK,EACfC,GAAkBN,GACpBA,EAAE,aAAeO,EAEfC,EAAmB,CAACC,EAAcC,IACpC,IAAI,MAAM,KAAKD,CAAI,WAAWC,CAAI,kBAAkB,EAC3CC,EAAN,KAAa,CAiBhB,aAAc,CAhBd,aAA6B,CAAC,EAC9B,WAAyBC,EAAW,CAAE,WAAY,CAAC,CAAE,CAAC,EACtD,mBAAgB,IAAI,MACpB,aAAyB,CAAC,EAC1B,cAAW,IAAI,MACf,UAAoC,CAAC,EACrC,gBAAyB,CACrB,OAAAC,EACA,SAAAC,GACA,OAAAC,CACJ,EACA,cAAW,GACX,mBAAgB,EAChB,cAAW,IAAI,IACf,mBAAgB,IAAI,MAgJpB,yBAAsB,EA3HtB,CAEA,IAAI,SAAU,CACV,OAAOC,EACX,CAEA,QAAQC,EAAiC,CACrC,IAAMC,EAAmB,IAAI,IAAoB,KAAK,OAAO,EAE7DD,EAAc,QAASE,GAAW,CAC9B,GAAIA,EAAO,iBACP,QACUC,KAAsBD,EACvB,gBAEL,GACI,CAACD,EAAiB,IAAIE,CAAkB,EAExC,MAAM,IAAI,MACN,WAAWD,EAAO,IAAI,sBAAsBC,CAAkB,gBAClE,EAKZ,IAAIC,EACJ,GAAItB,GAAqBoB,CAAM,EAAG,CAC9B,GAAI,KAAK,cAAc,SAASA,CAAM,EAClC,MAAMX,EAAiB,eAAgBW,EAAO,IAAI,EAEtD,KAAK,cAAc,KAAKA,CAAM,CAClC,SAAWjB,GAAgBiB,CAAM,EAAG,CAChC,GAAI,KAAK,SAAS,SAASA,CAAM,EAC7B,MAAMX,EAAiB,UAAWW,EAAO,IAAI,EAEjD,KAAK,SAAS,KAAKA,CAAM,EACzBE,EAAoBF,EAAO,YAC/B,SAAWb,GAAea,CAAM,EAAG,CAC/B,GAAM,KAAK,QAAQA,EAAO,IAAI,EAC1B,MAAMX,EAAiB,SAAUW,EAAO,IAAI,EAEhD,KAAK,QAAQA,EAAO,IAAI,EAAIA,CAChC,SAAWf,GAAkBe,CAAM,EAAG,CAClC,GAAI,KAAK,QAAQ,SAASA,CAAM,EAC5B,MAAMX,EAAiB,YAAaW,EAAO,IAAI,EAEnD,KAAK,QAAQ,KAAKA,CAAM,EACxBE,EAAoBF,EAAO,YAC/B,KACI,OAAM,IAAI,MAAM,wBAAwBA,CAAM,EAAE,EAGhDE,GACAA,EAAkB,CACd,MAAO,KAAK,MACZ,yBAA0B,KAAK,yBAC1B,KAAK,IAAI,EACd,WAAY,KAAK,WAAW,KAAK,IAAI,EACrC,gBAAiB,KAAK,gBAAgB,KAAK,IAAI,EAC/C,QAAS,KAAK,QACd,WAAY,KAAK,WACjB,aAAc,KAAK,aAAa,KAAK,IAAI,EACzC,uBAAwB,KAAK,uBAAuB,KAChD,IACJ,CAEJ,CAAC,EAWLH,EAAiB,IAAIC,CAAM,CAC/B,CAAC,EAED,KAAK,aAAa,SAAS,IAAI,CACnC,CAgCQ,uBAAuBG,EAAkB,CAC7C,IAAMC,EAAa,KAAK,SAAS,IAAID,CAAO,EAC5C,GAAIC,EAAY,CACZ,QAAWC,KAAWD,EAAW,IAC7BC,EAAQ,EAEZ,KAAK,SAAS,OAAOF,CAAO,CAChC,CACJ,CAGQ,WAA6BG,EAAe,CAChD,KAAK,cAAc,QAASD,GAAYA,EAAQ,CAAC,EACjD,KAAK,cAAgB,KAAK,cAAc,MAAM,CAAC,EAE/C,IAAME,EAAeC,EAAM,KAAK,MAAM,MAAOF,CAAU,EACvD,KAAK,MAAQb,EAAWc,CAAY,EAEZ,KAAK,UAAU,KAAK,MAAM,KAAK,EAC/B,KAAK,mBASjC,CAEQ,mBAAmBE,EAAgB,CACvC,IAAMF,EAAe,CAAE,GAAG,KAAK,MAAM,KAAM,EAC3C,QAAWG,KAAOD,EAAM,CACpB,IAAME,EAAQD,EAAI,MAAM,GAAG,EACvBE,EAAYD,EAAM,CAAC,EACnBE,EAAWN,EACf,QAASO,EAAI,EAAGA,EAAIH,EAAM,OAAQG,IAAK,CACnC,IAAMC,EAAOJ,EAAMG,CAAC,EACfD,EAASD,CAAS,IACnBC,EAASD,CAAS,EAAI,CAAC,GAE3BC,EAAWA,EAASD,CAAS,EAC7BA,EAAYG,CAChB,CACA,OAAOF,EAASD,CAAS,CAC7B,CACA,KAAK,MAAQnB,EAAWc,CAAY,EACpC,KAAK,aAAa,SAAS,IAAI,CACnC,CAEQ,yBAAyBS,EAAcC,EAAY,CACvD,IAAMN,EAAQK,EAAK,MAAM,GAAG,EACxBH,EAAW,KAAK,MACpB,QAAS,EAAI,EAAG,EAAIF,EAAM,OAAS,EAAG,IAAK,CACvC,IAAMI,EAAOJ,EAAM,CAAC,EACfE,EAASE,CAAI,IACdF,EAASE,CAAI,EAAI,CAAC,GAEtBF,EAAWA,EAASE,CAAI,CAC5B,CACA,IAAMG,EAAOP,EAAMA,EAAM,OAAS,CAAC,EAC7BE,EAASK,CAAI,IACnBL,EAASK,CAAI,EAAI,KAAK,WAAW,OAAOD,CAAK,EAEjD,CAEA,aAAgB1B,EAAc,CAC1B,OAAQ,KAAK,MAAcA,CAAI,CACnC,CAEQ,aAAa4B,EAAsB,CACvC,IAAMC,EAAoB,IAAI,IAE9B,KAAK,QAAQ,QAAQ,CAACvC,EAAGwC,IAAO,CAC5B,KAAK,YAAYF,EAAcG,GAAO,CAC7BD,GAAI,KAAK,uBAAuBC,CAAE,EAEvC,QAAWC,KAAUD,EAAG,QAAS,CAC7B,IAAME,EAAgB,GAAGF,EAAG,QAAQC,CAAM,CAAC,IAAM,GAC7CE,EAAaD,EAEjB,GAAI,CAACD,EAAO,WAAW1C,EAAE,IAAI,EAAG,SAQhC,GANIyC,EAAG,GAAG,SAAW,IACjBA,EAAG,GAAK,MAAM,KAAK,QAAQ,IAAI,KAAK,eAAe,IAGvDF,EAAkB,MAAM,EAEpBvC,EAAE,kBAAmB,CACrB,IAAM6C,EAAeJ,EAAG,QAAQ,YAAY,EAI5C,GAAI,CAHY,CAAC,GAAGzC,EAAE,iBAAiB,EAAE,KAAM8C,GAC3CD,EAAa,MAAMC,CAAC,CACxB,EAEI,MAAM,IAAI,MACN,IAAIL,EAAG,OAAO,sBAAsBC,CAAM,cACtC,CACI,CAAC,GAAG1C,EAAE,iBAAiB,EAAE,IAAK+C,GAC1B,IAAIA,CAAC,GACT,CACJ,EAAE,KAAK,IAAI,CACf,EACJ,CAER,CAEA,IAAIC,GAASN,EAAO,MAAM1C,EAAE,KAAK,MAAM,EACnC,CAAC6B,EAAK,GAAGoB,EAAoB,EAAID,GAAO,MAAM,GAAG,EACrD,GAAIhD,EAAE,kBAAoB6B,EAAI,OAAS,EACnC,MAAM,IAAI,MAAM,IAAIa,CAAM,uBAAuB,EAErD,GAAI1C,EAAE,iBAAmB6B,EAAI,SAAW,EACpC,MAAM,IAAI,MAAM,IAAIa,CAAM,2BAA2B,EAErDb,EAAI,SACJA,EAAMA,EAAI,CAAC,EAAE,YAAY,EAAIA,EAAI,MAAM,CAAC,GAG5C,IAAMqB,EAAeD,GAAqB,IAAKE,GAAM,CACjD,GAAM,CAACC,EAAO,GAAGC,CAAI,EAAIF,EAAE,MAAM,GAAG,EACpC,MAAO,CAAE,MAAAC,EAAO,KAAAC,CAAK,CACzB,CAAC,EACD,GAAIrD,EAAE,kBACF,QAAWsD,KAAYJ,EACnB,GAAI,CAAClD,EAAE,iBAAiB,IAAIsD,EAAS,KAAK,EACtC,MAAM,IAAI,MACN,IAAIA,EAAS,KAAK,kBACtB,EAIZ,IAAMC,EAAY,IAAI,IACtB,QAAWD,KAAYJ,EACnBK,EAAU,IAAID,EAAS,MAAOA,EAAS,IAAI,EAG/C,GAAItD,EAAE,yBAA2B4C,EAAW,OACxC,MAAM,IAAI,MACN,IAAIF,CAAM,8BACd,EAEJ,GAAI1C,EAAE,wBAA0B,CAAC4C,EAAW,OACxC,MAAM,IAAI,MACN,IAAIF,CAAM,kCACd,EAGJ,IAAMc,EAAa,OAEfxD,EAAE,iBACF4C,EAAaA,EACR,MAAM;AAAA,CAAI,EACV,IAAK5C,GAAcA,EAAE,KAAK,CAAC,EAC3B,KAAK,GAAG,GAGjB,IAAMyD,GAAa,CACf,GAAIzD,EAAE,eAAe,KAAO,CAAC,EAC7B,GAAG,KAAK,cACR,GAAIA,EAAE,eAAe,MAAQ,CAAC,CAClC,EACA,QAAW0D,KAAaD,GAAY,CAChC,GAAIlB,EAAkB,IAAImB,CAAS,EAAG,SACtCnB,EAAkB,IAAImB,CAAS,EAE/B,IAAMC,EAAkBf,EAAW,MAAMY,CAAU,EAC7CI,EAAyB,CAAC,EAEhCD,EAAgB,QAASE,GAAQ,CAC7B,IAAIC,EAAUD,EACRE,EAAU,CACZ,GAAGD,EAAQ,SAASJ,EAAU,MAAM,CACxC,EACA,GAAIK,EAAQ,OACR,QAAWC,KAASD,EAAS,CACzB,GAAI,CAACC,EAAM,OAAQ,SACnB,GAAM,CAAE,OAAAC,CAAO,EAAID,EACb,CAAE,MAAAE,EAAM,EAAID,EAClBH,EAAUA,EAAQ,QACdI,GACAR,EAAU,SAASO,CAAM,CAC7B,CACJ,CAEJL,EAAa,KAAKE,CAAO,CAC7B,CAAC,EAGDlB,EAAagB,EAAa,KAAK,IAAI,CACvC,CAEA,IAAMO,EAAwB,CAC1B,MAAO,IAAM,KAAK,MAClB,WAAY,KAAK,WAAW,KAAK,IAAI,EACrC,yBAA0B,KAAK,yBAC1B,KAAK,IAAI,EACd,gBAAiB,KAAK,gBAAgB,KAAK,IAAI,EAC/C,aAAc,KAAK,aAAa,KAAK,IAAI,EACzC,uBAAwB,KAAK,uBACxB,KAAK,IAAI,EACd,YAAa,KAAK,YAAY,KAAK,IAAI,EACvC,QAAS,KAAK,QACd,WAAY,KAAK,WACjB,GAAA1B,EACA,OAAAC,EACA,IAAAb,EACA,cAAAc,EACA,WAAAC,EACA,aAAc,IAAM,CAChB,MAAM,IAAI,MAAM,iCAAiC,CACrD,EACA,UAAAW,CAEJ,EAEA,GACI,CAACvD,EAAE,mCAAmCmE,CAAG,GACzC,CAACnE,EAAE,yBAA2B4C,EAAW,OAC3C,CACE,IAAMwB,EAAaxB,EACd,MAAMY,CAAU,EAChB,IAAKa,GAAMA,EAAE,KAAK,CAAC,EACnB,OAAQA,GAAMA,EAAE,MAAM,EAC3BD,EAAWA,EAAW,OAAS,CAAC,EAAI,UAChCA,EAAWA,EAAW,OAAS,CAAC,CACpC,GACA,IAAME,EAASF,EAAW,IAAKC,GAAM,KAAKA,CAAC,EAAE,EAAE,KAC3C;AAAA,CACJ,EACME,EAAY;AAAA;AAAA;AAAA,IAGtCD,CAAM;AAAA;AAAA;AAAA,wEAG8D5B,CAAM;AAAA;AAAA;AAAA;AAAA;AAAA,IAK1E4B,EAAO,WAAW,IAAK,KAAK,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAmBT,GAAI,CACA,IAAME,EAAgBxE,EAAE,eAAiB,CAAC,EACpCyE,EAAK,IAAI,SACX,MACA,GAAGD,EACHD,CACJ,EACAJ,EAAI,aAAeM,CACvB,OAASC,EAAG,CACR,IAAMC,EAAM,IAAI,MACZ,2CAA2CJ,CAAS,aAAaG,CAAC,EACtE,EAQA,QAAQ,MAAMC,CAAG,EACjB,QACJ,CACJ,CAEA,IAAMnD,EAAUxB,EAAE,OAAOmE,CAAG,EACxB3C,IACK,KAAK,SAAS,IAAIiB,CAAE,GACrB,KAAK,SAAS,IAAIA,EAAI,CAClB,GAAIA,EAAG,GACP,IAAK,IAAI,GACb,CAAC,EAEL,KAAK,SAAS,IAAIA,CAAE,EAAG,IAAI,IAAIjB,CAAO,EAE9C,CACJ,CAAC,CACL,CAAC,CACL,CAEQ,iBACJoD,EACAC,EACF,CACE,IAAMjD,EAAO,OAAO,KAAKgD,CAAK,EAC9B,QAAS3C,EAAI,EAAGA,EAAIL,EAAK,OAAQK,IAAK,CAClC,IAAMJ,EAAMD,EAAKK,CAAC,EACZG,EAAQwC,EAAM/C,CAAG,EACjBiD,EAAW1C,aAAiB2C,EAC5BC,EAAc,OAAO5C,GAAU,UACjC,OAAO,KAAKA,CAAK,EAAE,OAAS,EAEhC,GAAI0C,EAAU,CACVD,EAAShD,EAAKO,CAAK,EACnB,QACJ,CAEK4C,GAEL,KAAK,iBAAiB5C,EAAOyC,CAAQ,CACzC,CACJ,CAEQ,YAAYA,EAAuD,CACvE,KAAK,iBAAiB,KAAK,MAAOA,CAAQ,CAC9C,CAEQ,YACJvD,EACAuD,EACAI,EAAgB,EAClB,CACE,GAAI,CAAC3D,EAAS,OACd,IAAMmB,EAAKyC,GAAqB5D,CAAO,EACvC,GAAKmB,EAML,IAJAoC,EAASpC,CAAE,EAEXwC,EAAgB,EAChB3D,EAAUA,EAAQ,kBACXA,GACH,KAAK,YAAYA,EAASuD,EAAUI,GAAe,EACnD3D,EAAUA,EAAQ,kBAE1B,CACJ,ECxfO,IAAM6D,GAAqB,CAC9B,MAAO,QACP,MAAO,QACP,MAAO,QACP,QAAS,UACT,OAAQ,SACR,OAAQ,SACR,MAAO,QACP,iBAAkB,kBACtB,EAGaC,GAA2BD,GAAmB,MC5B3D,IAAME,GAAK,IAAIC,EACfD,GAAG,KACCE,GACAC,GACAC,GACAC,GACAC,CACJ,EAEO,IAAMC,GAAWP,GCjBxBQ,GAAS,KAAK",
  "names": ["Star", "PLUGIN_ACTION", "PLUGIN_WATCHER", "PLUGIN_PREPROCESSOR", "PLUGIN_ATTRIBUTE", "Computed", "PLUGIN_ATTRIBUTE", "ctx", "store", "storeFromPossibleContents", "currentStore", "contents", "hasIfMissing", "actual", "key", "currentValue", "Store", "PLUGIN_ATTRIBUTE", "PLUGIN_PREPROCESSOR", "groups", "whole", "ctx", "possibleMergeStore", "actualMergeStore", "storeFromPossibleContents", "validJSIdentifier", "validNestedJSIdentifier", "wholePrefixSuffix", "rune", "prefix", "suffix", "nestable", "identifier", "ActionsProcessor", "PLUGIN_PREPROCESSOR", "wholePrefixSuffix", "action", "args", "withCtx", "x", "argsJoined", "SignalsProcessor", "PLUGIN_PREPROCESSOR", "wholePrefixSuffix", "groups", "signal", "method", "prefix", "parts", "methodName", "nestedSignal", "nodeHTMLorSVGElement", "node", "BRAND_SYMBOL", "RUNNING", "NOTIFIED", "OUTDATED", "DISPOSED", "HAS_ERROR", "TRACKING", "startBatch", "batchDepth", "endBatch", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "needsToRecompute", "err", "batch", "fn", "evalContext", "batchedEffect", "batchDepth", "batchIteration", "globalVersion", "addDependency", "signal", "evalContext", "node", "TRACKING", "Signal", "value", "BRAND_SYMBOL", "prev", "next", "fn", "effect", "prevContext", "startBatch", "endBatch", "needsToRecompute", "target", "prepareSources", "rollbackNode", "cleanupSources", "head", "Computed", "OUTDATED", "NOTIFIED", "RUNNING", "HAS_ERROR", "err", "computed", "cleanupEffect", "cleanup", "DISPOSED", "disposeEffect", "endEffect", "Effect", "finish", "DeepSignal", "getValue", "payload", "batch", "setValue", "deepSignal", "initialValue", "acc", "key", "value", "iKey", "signal", "peek", "Signal", "apply", "target", "patchItem", "targetResult", "k", "VERSION", "isPreprocessorPlugin", "p", "PLUGIN_PREPROCESSOR", "isWatcherPlugin", "PLUGIN_WATCHER", "isAttributePlugin", "PLUGIN_ATTRIBUTE", "isActionPlugin", "PLUGIN_ACTION", "alreadyExistsErr", "type", "name", "Engine", "deepSignal", "signal", "computed", "effect", "VERSION", "pluginsToLoad", "allLoadedPlugins", "plugin", "requiredPluginType", "globalInitializer", "element", "removalSet", "removal", "mergeStore", "revisedStore", "apply", "keys", "key", "parts", "currentID", "subStore", "i", "part", "path", "value", "last", "rootElement", "appliedProcessors", "pi", "el", "rawKey", "rawExpression", "expression", "lowerCaseTag", "r", "t", "keyRaw", "modifiersWithArgsArr", "modifiersArr", "m", "label", "args", "modifier", "modifiers", "splitRegex", "processors", "processor", "expressionParts", "revisedParts", "exp", "revised", "matches", "match", "groups", "whole", "ctx", "statements", "s", "joined", "fnContent", "argumentNames", "fn", "e", "err", "store", "callback", "isSignal", "Signal", "hasChildren", "siblingOffset", "nodeHTMLorSVGElement", "FragmentMergeModes", "DefaultFragmentMergeMode", "ds", "Engine", "ActionsProcessor", "SignalsProcessor", "Store", "Computed", "Star", "Datastar", "Datastar"]
}
